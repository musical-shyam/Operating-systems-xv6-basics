0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) (((void *) (a)) + KERNBASE)
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             cpunum(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 void            exit(void);
0358 int             fork(void);
0359 int             growproc(int);
0360 int             kill(int);
0361 void            pinit(void);
0362 void            procdump(void);
0363 void            scheduler(void) __attribute__((noreturn));
0364 void            sched(void);
0365 void            sleep(void*, struct spinlock*);
0366 void            userinit(void);
0367 int             wait(void);
0368 void            wakeup(void*);
0369 void            yield(void);
0370 
0371 
0372 void            swtch(struct context**, struct context*);
0373 
0374 
0375 void            acquire(struct spinlock*);
0376 void            getcallerpcs(void*, uint*);
0377 int             holding(struct spinlock*);
0378 void            initlock(struct spinlock*, char*);
0379 void            release(struct spinlock*);
0380 void            pushcli(void);
0381 void            popcli(void);
0382 
0383 
0384 void            acquiresleep(struct sleeplock*);
0385 void             releasesleep(struct sleeplock*);
0386 int             holdingsleep(struct sleeplock*);
0387 void            initsleeplock(struct sleeplock*, char*);
0388 
0389 
0390 int             memcmp(const void*, const void*, uint);
0391 void*           memmove(void*, const void*, uint);
0392 void*           memset(void*, int, uint);
0393 char*           safestrcpy(char*, const char*, int);
0394 int             strlen(const char*);
0395 int             strncmp(const char*, const char*, uint);
0396 char*           strncpy(char*, const char*, int);
0397 
0398 
0399 
0400 
0401 int             argint(int, int*);
0402 int             argptr(int, char**, int);
0403 int             argstr(int, char**);
0404 int             fetchint(uint, int*);
0405 int             fetchstr(uint, char**);
0406 void            syscall(void);
0407 
0408 
0409 void            timerinit(void);
0410 
0411 
0412 void            idtinit(void);
0413 extern uint     ticks;
0414 void            tvinit(void);
0415 extern struct spinlock tickslock;
0416 
0417 
0418 void            uartinit(void);
0419 void            uartintr(void);
0420 void            uartputc(int);
0421 
0422 
0423 void            seginit(void);
0424 void            kvmalloc(void);
0425 pde_t*          setupkvm(void);
0426 char*           uva2ka(pde_t*, char*);
0427 int             allocuvm(pde_t*, uint, uint);
0428 int             deallocuvm(pde_t*, uint, uint);
0429 void            freevm(pde_t*);
0430 void            inituvm(pde_t*, char*, uint);
0431 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0432 pde_t*          copyuvm(pde_t*, uint);
0433 void            switchuvm(struct proc*);
0434 void            switchkvm(void);
0435 int             copyout(pde_t*, uint, void*, uint);
0436 void            clearpteu(pde_t *pgdir, char *uva);
0437 
0438 
0439 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0440 
0441 
0442 
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_E     0x4       
0667 #define STA_C     0x4       
0668 #define STA_W     0x2       
0669 #define STA_R     0x2       
0670 #define STA_A     0x1       
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_CF           0x00000001      
0705 #define FL_PF           0x00000004      
0706 #define FL_AF           0x00000010      
0707 #define FL_ZF           0x00000040      
0708 #define FL_SF           0x00000080      
0709 #define FL_TF           0x00000100      
0710 #define FL_IF           0x00000200      
0711 #define FL_DF           0x00000400      
0712 #define FL_OF           0x00000800      
0713 #define FL_IOPL_MASK    0x00003000      
0714 #define FL_IOPL_0       0x00000000      
0715 #define FL_IOPL_1       0x00001000      
0716 #define FL_IOPL_2       0x00002000      
0717 #define FL_IOPL_3       0x00003000      
0718 #define FL_NT           0x00004000      
0719 #define FL_RF           0x00010000      
0720 #define FL_VM           0x00020000      
0721 #define FL_AC           0x00040000      
0722 #define FL_VIF          0x00080000      
0723 #define FL_VIP          0x00100000      
0724 #define FL_ID           0x00200000      
0725 
0726 
0727 #define CR0_PE          0x00000001      
0728 #define CR0_MP          0x00000002      
0729 #define CR0_EM          0x00000004      
0730 #define CR0_TS          0x00000008      
0731 #define CR0_ET          0x00000010      
0732 #define CR0_NE          0x00000020      
0733 #define CR0_WP          0x00010000      
0734 #define CR0_AM          0x00040000      
0735 #define CR0_NW          0x20000000      
0736 #define CR0_CD          0x40000000      
0737 #define CR0_PG          0x80000000      
0738 
0739 #define CR4_PSE         0x00000010      
0740 
0741 
0742 #define SEG_KCODE 1  
0743 #define SEG_KDATA 2  
0744 #define SEG_KCPU  3  
0745 #define SEG_UCODE 4  
0746 #define SEG_UDATA 5  
0747 #define SEG_TSS   6  
0748 
0749 
0750 
0751 #define NSEGS     7
0752 
0753 #ifndef __ASSEMBLER__
0754 
0755 struct segdesc {
0756   uint lim_15_0 : 16;  
0757   uint base_15_0 : 16; 
0758   uint base_23_16 : 8; 
0759   uint type : 4;       
0760   uint s : 1;          
0761   uint dpl : 2;        
0762   uint p : 1;          
0763   uint lim_19_16 : 4;  
0764   uint avl : 1;        
0765   uint rsv1 : 1;       
0766   uint db : 1;         
0767   uint g : 1;          
0768   uint base_31_24 : 8; 
0769 };
0770 
0771 
0772 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0773 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0774   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0775   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0776 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0777 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0778   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0779   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0780 #endif
0781 
0782 #define DPL_USER    0x3     
0783 
0784 
0785 #define STA_X       0x8     
0786 #define STA_E       0x4     
0787 #define STA_C       0x4     
0788 #define STA_W       0x2     
0789 #define STA_R       0x2     
0790 #define STA_A       0x1     
0791 
0792 
0793 #define STS_T16A    0x1     
0794 #define STS_LDT     0x2     
0795 #define STS_T16B    0x3     
0796 #define STS_CG16    0x4     
0797 #define STS_TG      0x5     
0798 #define STS_IG16    0x6     
0799 #define STS_TG16    0x7     
0800 #define STS_T32A    0x9     
0801 #define STS_T32B    0xB     
0802 #define STS_CG32    0xC     
0803 #define STS_IG32    0xE     
0804 #define STS_TG32    0xF     
0805 
0806 
0807 
0808 
0809 
0810 
0811 
0812 
0813 
0814 
0815 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0816 
0817 
0818 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0819 
0820 
0821 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0822 
0823 
0824 #define NPDENTRIES      1024    
0825 #define NPTENTRIES      1024    
0826 #define PGSIZE          4096    
0827 
0828 #define PGSHIFT         12      
0829 #define PTXSHIFT        12      
0830 #define PDXSHIFT        22      
0831 
0832 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0833 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0834 
0835 
0836 #define PTE_P           0x001   
0837 #define PTE_W           0x002   
0838 #define PTE_U           0x004   
0839 #define PTE_PWT         0x008   
0840 #define PTE_PCD         0x010   
0841 #define PTE_A           0x020   
0842 #define PTE_D           0x040   
0843 #define PTE_PS          0x080   
0844 #define PTE_MBZ         0x180   
0845 
0846 
0847 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0848 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0849 
0850 #ifndef __ASSEMBLER__
0851 typedef uint pte_t;
0852 
0853 
0854 struct taskstate {
0855   uint link;         
0856   uint esp0;         
0857   ushort ss0;        
0858   ushort padding1;
0859   uint *esp1;
0860   ushort ss1;
0861   ushort padding2;
0862   uint *esp2;
0863   ushort ss2;
0864   ushort padding3;
0865   void *cr3;         
0866   uint *eip;         
0867   uint eflags;
0868   uint eax;          
0869   uint ecx;
0870   uint edx;
0871   uint ebx;
0872   uint *esp;
0873   uint *ebp;
0874   uint esi;
0875   uint edi;
0876   ushort es;         
0877   ushort padding4;
0878   ushort cs;
0879   ushort padding5;
0880   ushort ss;
0881   ushort padding6;
0882   ushort ds;
0883   ushort padding7;
0884   ushort fs;
0885   ushort padding8;
0886   ushort gs;
0887   ushort padding9;
0888   ushort ldt;
0889   ushort padding10;
0890   ushort t;          
0891   ushort iomb;       
0892 };
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 struct gatedesc {
0902   uint off_15_0 : 16;   
0903   uint cs : 16;         
0904   uint args : 5;        
0905   uint rsv1 : 3;        
0906   uint type : 4;        
0907   uint s : 1;           
0908   uint dpl : 2;         
0909   uint p : 1;           
0910   uint off_31_16 : 16;  
0911 };
0912 
0913 
0914 
0915 
0916 
0917 
0918 
0919 
0920 
0921 #define SETGATE(gate, istrap, sel, off, d)                \
0922 {                                                         \
0923   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0924   (gate).cs = (sel);                                      \
0925   (gate).args = 0;                                        \
0926   (gate).rsv1 = 0;                                        \
0927   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0928   (gate).s = 0;                                           \
0929   (gate).dpl = (d);                                       \
0930   (gate).p = 1;                                           \
0931   (gate).off_31_16 = (uint)(off) >> 16;                  \
0932 }
0933 
0934 #endif
0935 
0936 
0937 
0938 
0939 
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 #define ELF_MAGIC 0x464C457FU  
0953 
0954 
0955 struct elfhdr {
0956   uint magic;  
0957   uchar elf[12];
0958   ushort type;
0959   ushort machine;
0960   uint version;
0961   uint entry;
0962   uint phoff;
0963   uint shoff;
0964   uint flags;
0965   ushort ehsize;
0966   ushort phentsize;
0967   ushort phnum;
0968   ushort shentsize;
0969   ushort shnum;
0970   ushort shstrndx;
0971 };
0972 
0973 
0974 struct proghdr {
0975   uint type;
0976   uint off;
0977   uint vaddr;
0978   uint paddr;
0979   uint filesz;
0980   uint memsz;
0981   uint flags;
0982   uint align;
0983 };
0984 
0985 
0986 #define ELF_PROG_LOAD           1
0987 
0988 
0989 #define ELF_PROG_FLAG_EXEC      1
0990 #define ELF_PROG_FLAG_WRITE     2
0991 #define ELF_PROG_FLAG_READ      4
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 .p2align 2
1027 .text
1028 .globl multiboot_header
1029 multiboot_header:
1030   
1031   
1032   .long magic
1033   .long flags
1034   .long (-magic-flags)
1035 
1036 
1037 
1038 
1039 .globl _start
1040 _start = V2P_WO(entry)
1041 
1042 
1043 .globl entry
1044 entry:
1045   
1046   movl    %cr4, %eax
1047   orl     $(CR4_PSE), %eax
1048   movl    %eax, %cr4
1049   
1050   movl    $(V2P_WO(entrypgdir)), %eax
1051   movl    %eax, %cr3
1052   
1053   movl    %cr0, %eax
1054   orl     $(CR0_PG|CR0_WP), %eax
1055   movl    %eax, %cr0
1056 
1057   
1058   movl $(stack + KSTACKSIZE), %esp
1059 
1060   
1061   
1062   
1063   
1064   mov $main, %eax
1065   jmp *%eax
1066 
1067 .comm stack, KSTACKSIZE
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 .code16
1122 .globl start
1123 start:
1124   cli
1125 
1126   
1127   xorw    %ax,%ax
1128   movw    %ax,%ds
1129   movw    %ax,%es
1130   movw    %ax,%ss
1131 
1132   
1133   
1134   
1135   lgdt    gdtdesc
1136   movl    %cr0, %eax
1137   orl     $CR0_PE, %eax
1138   movl    %eax, %cr0
1139 
1140   
1141   
1142   
1143   ljmpl    $(SEG_KCODE<<3), $(start32)
1144 
1145 .code32  
1146 start32:
1147   
1148   movw    $(SEG_KDATA<<3), %ax    
1149   movw    %ax, %ds                
1150   movw    %ax, %es                
1151   movw    %ax, %ss                
1152   movw    $0, %ax                 
1153   movw    %ax, %fs                
1154   movw    %ax, %gs                
1155 
1156   
1157   movl    %cr4, %eax
1158   orl     $(CR4_PSE), %eax
1159   movl    %eax, %cr4
1160   
1161   movl    (start-12), %eax
1162   movl    %eax, %cr3
1163   
1164   movl    %cr0, %eax
1165   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1166   movl    %eax, %cr0
1167 
1168   
1169   movl    (start-4), %esp
1170   
1171   call	 *(start-8)
1172 
1173   movw    $0x8a00, %ax
1174   movw    %ax, %dx
1175   outw    %ax, %dx
1176   movw    $0x8ae0, %ax
1177   outw    %ax, %dx
1178 spin:
1179   jmp     spin
1180 
1181 .p2align 2
1182 gdt:
1183   SEG_NULLASM
1184   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1185   SEG_ASM(STA_W, 0, 0xffffffff)
1186 
1187 
1188 gdtdesc:
1189   .word   (gdtdesc - gdt - 1)
1190   .long   gdt
1191 
1192 
1193 
1194 
1195 
1196 
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();     
1223   seginit();       
1224   cprintf("\ncpu%d: starting xv6\n\n", cpunum());
1225   picinit();       
1226   ioapicinit();    
1227   consoleinit();   
1228   uartinit();      
1229   pinit();         
1230   tvinit();        
1231   binit();         
1232   fileinit();      
1233   ideinit();       
1234   if(!ismp)
1235     timerinit();   
1236   startothers();   
1237   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1238   userinit();      
1239   mpmain();        
1240 }
1241 
1242 
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 static void
1252 mpenter(void)
1253 {
1254   switchkvm();
1255   seginit();
1256   lapicinit();
1257   mpmain();
1258 }
1259 
1260 
1261 static void
1262 mpmain(void)
1263 {
1264   cprintf("cpu%d: starting\n", cpunum());
1265   idtinit();       
1266   xchg(&cpu->started, 1); 
1267   scheduler();     
1268 }
1269 
1270 pde_t entrypgdir[];  
1271 
1272 
1273 static void
1274 startothers(void)
1275 {
1276   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1277   uchar *code;
1278   struct cpu *c;
1279   char *stack;
1280 
1281   
1282   
1283   
1284   code = P2V(0x7000);
1285   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1286 
1287   for(c = cpus; c < cpus+ncpu; c++){
1288     if(c == cpus+cpunum())  
1289       continue;
1290 
1291     
1292     
1293     
1294     stack = kalloc();
1295     *(void**)(code-4) = stack + KSTACKSIZE;
1296     *(void**)(code-8) = mpenter;
1297     *(int**)(code-12) = (void *) V2P(entrypgdir);
1298 
1299     lapicstartap(c->apicid, V2P(code));
1300     
1301     while(c->started == 0)
1302       ;
1303   }
1304 }
1305 
1306 
1307 
1308 
1309 
1310 
1311 __attribute__((__aligned__(PGSIZE)))
1312 pde_t entrypgdir[NPDENTRIES] = {
1313   
1314   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1315   
1316   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1317 };
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 struct spinlock {
1352   uint locked;       
1353 
1354   
1355   char *name;        
1356   struct cpu *cpu;   
1357   uint pcs[10];      
1358                      
1359 };
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 #include "types.h"
1403 #include "defs.h"
1404 #include "param.h"
1405 #include "x86.h"
1406 #include "memlayout.h"
1407 #include "mmu.h"
1408 #include "proc.h"
1409 #include "spinlock.h"
1410 
1411 void
1412 initlock(struct spinlock *lk, char *name)
1413 {
1414   lk->name = name;
1415   lk->locked = 0;
1416   lk->cpu = 0;
1417 }
1418 
1419 
1420 
1421 
1422 
1423 void
1424 acquire(struct spinlock *lk)
1425 {
1426   pushcli(); 
1427   if(holding(lk))
1428     panic("acquire");
1429 
1430   
1431   while(xchg(&lk->locked, 1) != 0)
1432     ;
1433 
1434   
1435   
1436   
1437   __sync_synchronize();
1438 
1439   
1440   lk->cpu = cpu;
1441   getcallerpcs(&lk, lk->pcs);
1442 }
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 void
1452 release(struct spinlock *lk)
1453 {
1454   if(!holding(lk))
1455     panic("release");
1456 
1457   lk->pcs[0] = 0;
1458   lk->cpu = 0;
1459 
1460   
1461   
1462   
1463   
1464   
1465   __sync_synchronize();
1466 
1467   
1468   
1469   
1470   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1471 
1472   popcli();
1473 }
1474 
1475 
1476 void
1477 getcallerpcs(void *v, uint pcs[])
1478 {
1479   uint *ebp;
1480   int i;
1481 
1482   ebp = (uint*)v - 2;
1483   for(i = 0; i < 10; i++){
1484     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1485       break;
1486     pcs[i] = ebp[1];     
1487     ebp = (uint*)ebp[0]; 
1488   }
1489   for(; i < 10; i++)
1490     pcs[i] = 0;
1491 }
1492 
1493 
1494 int
1495 holding(struct spinlock *lock)
1496 {
1497   return lock->locked && lock->cpu == cpu;
1498 }
1499 
1500 
1501 
1502 
1503 
1504 void
1505 pushcli(void)
1506 {
1507   int eflags;
1508 
1509   eflags = readeflags();
1510   cli();
1511   if(cpu->ncli == 0)
1512     cpu->intena = eflags & FL_IF;
1513   cpu->ncli += 1;
1514 }
1515 
1516 void
1517 popcli(void)
1518 {
1519   if(readeflags()&FL_IF)
1520     panic("popcli - interruptible");
1521   if(--cpu->ncli < 0)
1522     panic("popcli");
1523   if(cpu->ncli == 0 && cpu->intena)
1524     sti();
1525 }
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 #include "param.h"
1551 #include "types.h"
1552 #include "defs.h"
1553 #include "x86.h"
1554 #include "memlayout.h"
1555 #include "mmu.h"
1556 #include "proc.h"
1557 #include "elf.h"
1558 
1559 extern char data[];  
1560 pde_t *kpgdir;  
1561 
1562 
1563 
1564 void
1565 seginit(void)
1566 {
1567   struct cpu *c;
1568 
1569   
1570   
1571   
1572   
1573   c = &cpus[cpunum()];
1574   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1575   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1576   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1577   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1578 
1579   
1580   c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
1581 
1582   lgdt(c->gdt, sizeof(c->gdt));
1583   loadgs(SEG_KCPU << 3);
1584 
1585   
1586   cpu = c;
1587   proc = 0;
1588 }
1589 
1590 
1591 
1592 
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 
1602 
1603 static pte_t *
1604 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1605 {
1606   pde_t *pde;
1607   pte_t *pgtab;
1608 
1609   pde = &pgdir[PDX(va)];
1610   if(*pde & PTE_P){
1611     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1612   } else {
1613     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1614       return 0;
1615     
1616     memset(pgtab, 0, PGSIZE);
1617     
1618     
1619     
1620     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1621   }
1622   return &pgtab[PTX(va)];
1623 }
1624 
1625 
1626 
1627 
1628 static int
1629 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1630 {
1631   char *a, *last;
1632   pte_t *pte;
1633 
1634   a = (char*)PGROUNDDOWN((uint)va);
1635   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1636   for(;;){
1637     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1638       return -1;
1639     if(*pte & PTE_P)
1640       panic("remap");
1641     *pte = pa | perm | PTE_P;
1642     if(a == last)
1643       break;
1644     a += PGSIZE;
1645     pa += PGSIZE;
1646   }
1647   return 0;
1648 }
1649 
1650 
1651 
1652 
1653 
1654 
1655 
1656 
1657 
1658 
1659 
1660 
1661 
1662 
1663 
1664 
1665 
1666 
1667 
1668 
1669 
1670 
1671 
1672 
1673 static struct kmap {
1674   void *virt;
1675   uint phys_start;
1676   uint phys_end;
1677   int perm;
1678 } kmap[] = {
1679  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1680  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1681  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1682  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1683 };
1684 
1685 
1686 pde_t*
1687 setupkvm(void)
1688 {
1689   pde_t *pgdir;
1690   struct kmap *k;
1691 
1692   if((pgdir = (pde_t*)kalloc()) == 0)
1693     return 0;
1694   memset(pgdir, 0, PGSIZE);
1695   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1696     panic("PHYSTOP too high");
1697   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1698     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1699                 (uint)k->phys_start, k->perm) < 0)
1700       return 0;
1701   return pgdir;
1702 }
1703 
1704 
1705 
1706 void
1707 kvmalloc(void)
1708 {
1709   kpgdir = setupkvm();
1710   switchkvm();
1711 }
1712 
1713 
1714 
1715 void
1716 switchkvm(void)
1717 {
1718   lcr3(V2P(kpgdir));   
1719 }
1720 
1721 
1722 void
1723 switchuvm(struct proc *p)
1724 {
1725   pushcli();
1726   cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
1727   cpu->gdt[SEG_TSS].s = 0;
1728   cpu->ts.ss0 = SEG_KDATA << 3;
1729   cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
1730   
1731   
1732   cpu->ts.iomb = (ushort) 0xFFFF;
1733   ltr(SEG_TSS << 3);
1734   if(p->pgdir == 0)
1735     panic("switchuvm: no pgdir");
1736   lcr3(V2P(p->pgdir));  
1737   popcli();
1738 }
1739 
1740 
1741 
1742 
1743 
1744 
1745 
1746 
1747 
1748 
1749 
1750 
1751 
1752 void
1753 inituvm(pde_t *pgdir, char *init, uint sz)
1754 {
1755   char *mem;
1756 
1757   if(sz >= PGSIZE)
1758     panic("inituvm: more than a page");
1759   mem = kalloc();
1760   memset(mem, 0, PGSIZE);
1761   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1762   memmove(mem, init, sz);
1763 }
1764 
1765 
1766 
1767 int
1768 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1769 {
1770   uint i, pa, n;
1771   pte_t *pte;
1772 
1773   if((uint) addr % PGSIZE != 0)
1774     panic("loaduvm: addr must be page aligned");
1775   for(i = 0; i < sz; i += PGSIZE){
1776     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1777       panic("loaduvm: address should exist");
1778     pa = PTE_ADDR(*pte);
1779     if(sz - i < PGSIZE)
1780       n = sz - i;
1781     else
1782       n = PGSIZE;
1783     if(readi(ip, P2V(pa), offset+i, n) != n)
1784       return -1;
1785   }
1786   return 0;
1787 }
1788 
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 int
1803 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1804 {
1805   char *mem;
1806   uint a;
1807 
1808   if(newsz >= KERNBASE)
1809     return 0;
1810   if(newsz < oldsz)
1811     return oldsz;
1812 
1813   a = PGROUNDUP(oldsz);
1814   for(; a < newsz; a += PGSIZE){
1815     mem = kalloc();
1816     if(mem == 0){
1817       cprintf("allocuvm out of memory\n");
1818       deallocuvm(pgdir, newsz, oldsz);
1819       return 0;
1820     }
1821     memset(mem, 0, PGSIZE);
1822     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1823       cprintf("allocuvm out of memory (2)\n");
1824       deallocuvm(pgdir, newsz, oldsz);
1825       kfree(mem);
1826       return 0;
1827     }
1828   }
1829   return newsz;
1830 }
1831 
1832 
1833 
1834 
1835 
1836 int
1837 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1838 {
1839   pte_t *pte;
1840   uint a, pa;
1841 
1842   if(newsz >= oldsz)
1843     return oldsz;
1844 
1845   a = PGROUNDUP(newsz);
1846   for(; a  < oldsz; a += PGSIZE){
1847     pte = walkpgdir(pgdir, (char*)a, 0);
1848     if(!pte)
1849       a += (NPTENTRIES - 1) * PGSIZE;
1850     else if((*pte & PTE_P) != 0){
1851       pa = PTE_ADDR(*pte);
1852       if(pa == 0)
1853         panic("kfree");
1854       char *v = P2V(pa);
1855       kfree(v);
1856       *pte = 0;
1857     }
1858   }
1859   return newsz;
1860 }
1861 
1862 
1863 
1864 void
1865 freevm(pde_t *pgdir)
1866 {
1867   uint i;
1868 
1869   if(pgdir == 0)
1870     panic("freevm: no pgdir");
1871   deallocuvm(pgdir, KERNBASE, 0);
1872   for(i = 0; i < NPDENTRIES; i++){
1873     if(pgdir[i] & PTE_P){
1874       char * v = P2V(PTE_ADDR(pgdir[i]));
1875       kfree(v);
1876     }
1877   }
1878   kfree((char*)pgdir);
1879 }
1880 
1881 
1882 
1883 void
1884 clearpteu(pde_t *pgdir, char *uva)
1885 {
1886   pte_t *pte;
1887 
1888   pte = walkpgdir(pgdir, uva, 0);
1889   if(pte == 0)
1890     panic("clearpteu");
1891   *pte &= ~PTE_U;
1892 }
1893 
1894 
1895 
1896 
1897 
1898 
1899 
1900 
1901 
1902 pde_t*
1903 copyuvm(pde_t *pgdir, uint sz)
1904 {
1905   pde_t *d;
1906   pte_t *pte;
1907   uint pa, i, flags;
1908   char *mem;
1909 
1910   if((d = setupkvm()) == 0)
1911     return 0;
1912   for(i = 0; i < sz; i += PGSIZE){
1913     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
1914       panic("copyuvm: pte should exist");
1915     if(!(*pte & PTE_P))
1916       panic("copyuvm: page not present");
1917     pa = PTE_ADDR(*pte);
1918     flags = PTE_FLAGS(*pte);
1919     if((mem = kalloc()) == 0)
1920       goto bad;
1921     memmove(mem, (char*)P2V(pa), PGSIZE);
1922     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
1923       goto bad;
1924   }
1925   return d;
1926 
1927 bad:
1928   freevm(d);
1929   return 0;
1930 }
1931 
1932 
1933 char*
1934 uva2ka(pde_t *pgdir, char *uva)
1935 {
1936   pte_t *pte;
1937 
1938   pte = walkpgdir(pgdir, uva, 0);
1939   if((*pte & PTE_P) == 0)
1940     return 0;
1941   if((*pte & PTE_U) == 0)
1942     return 0;
1943   return (char*)P2V(PTE_ADDR(*pte));
1944 }
1945 
1946 
1947 
1948 
1949 
1950 
1951 
1952 
1953 int
1954 copyout(pde_t *pgdir, uint va, void *p, uint len)
1955 {
1956   char *buf, *pa0;
1957   uint n, va0;
1958 
1959   buf = (char*)p;
1960   while(len > 0){
1961     va0 = (uint)PGROUNDDOWN(va);
1962     pa0 = uva2ka(pgdir, (char*)va0);
1963     if(pa0 == 0)
1964       return -1;
1965     n = PGSIZE - (va - va0);
1966     if(n > len)
1967       n = len;
1968     memmove(pa0 + (va - va0), buf, n);
1969     len -= n;
1970     buf += n;
1971     va = va0 + PGSIZE;
1972   }
1973   return 0;
1974 }
1975 
1976 
1977 
1978 
1979 
1980 
1981 
1982 
1983 
1984 
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 struct cpu {
2002   uchar apicid;                
2003   struct context *scheduler;   
2004   struct taskstate ts;         
2005   struct segdesc gdt[NSEGS];   
2006   volatile uint started;       
2007   int ncli;                    
2008   int intena;                  
2009 
2010   
2011   struct cpu *cpu;
2012   struct proc *proc;           
2013 };
2014 
2015 extern struct cpu cpus[NCPU];
2016 extern int ncpu;
2017 
2018 
2019 
2020 
2021 
2022 
2023 
2024 
2025 
2026 extern struct cpu *cpu asm("%gs:0");       
2027 extern struct proc *proc asm("%gs:4");     
2028 
2029 
2030 
2031 
2032 
2033 
2034 
2035 
2036 
2037 
2038 
2039 struct context {
2040   uint edi;
2041   uint esi;
2042   uint ebx;
2043   uint ebp;
2044   uint eip;
2045 };
2046 
2047 
2048 
2049 
2050 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2051 
2052 
2053 struct proc {
2054   uint sz;                     
2055   pde_t* pgdir;                
2056   char *kstack;                
2057   enum procstate state;        
2058   int pid;                     
2059   struct proc *parent;         
2060   struct trapframe *tf;        
2061   struct context *context;     
2062   void *chan;                  
2063   int killed;                  
2064   struct file *ofile[NOFILE];  
2065   struct inode *cwd;           
2066   char name[16];               
2067 };
2068 
2069 
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 
2080 
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 #include "types.h"
2101 #include "defs.h"
2102 #include "param.h"
2103 #include "memlayout.h"
2104 #include "mmu.h"
2105 #include "x86.h"
2106 #include "proc.h"
2107 #include "spinlock.h"
2108 
2109 struct {
2110   struct spinlock lock;
2111   struct proc proc[NPROC];
2112 } ptable;
2113 
2114 static struct proc *initproc;
2115 
2116 int nextpid = 1;
2117 extern void forkret(void);
2118 extern void trapret(void);
2119 
2120 static void wakeup1(void *chan);
2121 
2122 void
2123 pinit(void)
2124 {
2125   initlock(&ptable.lock, "ptable");
2126 }
2127 
2128 
2129 
2130 
2131 
2132 static struct proc*
2133 allocproc(void)
2134 {
2135   struct proc *p;
2136   char *sp;
2137 
2138   acquire(&ptable.lock);
2139 
2140   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2141     if(p->state == UNUSED)
2142       goto found;
2143 
2144   release(&ptable.lock);
2145   return 0;
2146 
2147 found:
2148   p->state = EMBRYO;
2149   p->pid = nextpid++;
2150   release(&ptable.lock);
2151 
2152   
2153   if((p->kstack = kalloc()) == 0){
2154     p->state = UNUSED;
2155     return 0;
2156   }
2157   sp = p->kstack + KSTACKSIZE;
2158 
2159   
2160   sp -= sizeof *p->tf;
2161   p->tf = (struct trapframe*)sp;
2162 
2163   
2164   
2165   sp -= 4;
2166   *(uint*)sp = (uint)trapret;
2167 
2168   sp -= sizeof *p->context;
2169   p->context = (struct context*)sp;
2170   memset(p->context, 0, sizeof *p->context);
2171   p->context->eip = (uint)forkret;
2172 
2173   return p;
2174 }
2175 
2176 
2177 void
2178 userinit(void)
2179 {
2180   struct proc *p;
2181   extern char _binary_initcode_start[], _binary_initcode_size[];
2182 
2183   p = allocproc();
2184 
2185   initproc = p;
2186   if((p->pgdir = setupkvm()) == 0)
2187     panic("userinit: out of memory?");
2188   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2189   p->sz = PGSIZE;
2190   memset(p->tf, 0, sizeof(*p->tf));
2191   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2192   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2193   p->tf->es = p->tf->ds;
2194   p->tf->ss = p->tf->ds;
2195   p->tf->eflags = FL_IF;
2196   p->tf->esp = PGSIZE;
2197   p->tf->eip = 0;  
2198 
2199 
2200   safestrcpy(p->name, "initcode", sizeof(p->name));
2201   p->cwd = namei("/");
2202 
2203   
2204   
2205   
2206   
2207   acquire(&ptable.lock);
2208 
2209   p->state = RUNNABLE;
2210 
2211   release(&ptable.lock);
2212 }
2213 
2214 
2215 
2216 int
2217 growproc(int n)
2218 {
2219   uint sz;
2220 
2221   sz = proc->sz;
2222   if(n > 0){
2223     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
2224       return -1;
2225   } else if(n < 0){
2226     if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
2227       return -1;
2228   }
2229   proc->sz = sz;
2230   switchuvm(proc);
2231   return 0;
2232 }
2233 
2234 
2235 
2236 
2237 int
2238 fork(void)
2239 {
2240   int i, pid;
2241   struct proc *np;
2242 
2243   
2244   if((np = allocproc()) == 0){
2245     return -1;
2246   }
2247 
2248 
2249 
2250   
2251   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
2252     kfree(np->kstack);
2253     np->kstack = 0;
2254     np->state = UNUSED;
2255     return -1;
2256   }
2257   np->sz = proc->sz;
2258   np->parent = proc;
2259   *np->tf = *proc->tf;
2260 
2261   
2262   np->tf->eax = 0;
2263 
2264   for(i = 0; i < NOFILE; i++)
2265     if(proc->ofile[i])
2266       np->ofile[i] = filedup(proc->ofile[i]);
2267   np->cwd = idup(proc->cwd);
2268 
2269   safestrcpy(np->name, proc->name, sizeof(proc->name));
2270 
2271   pid = np->pid;
2272 
2273   acquire(&ptable.lock);
2274 
2275   np->state = RUNNABLE;
2276 
2277   release(&ptable.lock);
2278 
2279   return pid;
2280 }
2281 
2282 
2283 
2284 
2285 void
2286 exit(void)
2287 {
2288   struct proc *p;
2289   int fd;
2290 
2291   if(proc == initproc)
2292     panic("init exiting");
2293 
2294   
2295   for(fd = 0; fd < NOFILE; fd++){
2296     if(proc->ofile[fd]){
2297       fileclose(proc->ofile[fd]);
2298       proc->ofile[fd] = 0;
2299     }
2300   }
2301 
2302   begin_op();
2303   iput(proc->cwd);
2304   end_op();
2305   proc->cwd = 0;
2306 
2307   acquire(&ptable.lock);
2308 
2309   
2310   wakeup1(proc->parent);
2311 
2312   
2313   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2314     if(p->parent == proc){
2315       p->parent = initproc;
2316       if(p->state == ZOMBIE)
2317         wakeup1(initproc);
2318     }
2319   }
2320 
2321   
2322   proc->state = ZOMBIE;
2323   sched();
2324   panic("zombie exit");
2325 }
2326 
2327 
2328 
2329 int
2330 wait(void)
2331 {
2332   struct proc *p;
2333   int havekids, pid;
2334 
2335   acquire(&ptable.lock);
2336   for(;;){
2337     
2338     havekids = 0;
2339     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2340       if(p->parent != proc)
2341         continue;
2342       havekids = 1;
2343       if(p->state == ZOMBIE){
2344         
2345         pid = p->pid;
2346         kfree(p->kstack);
2347         p->kstack = 0;
2348         freevm(p->pgdir);
2349         p->pid = 0;
2350         p->parent = 0;
2351         p->name[0] = 0;
2352         p->killed = 0;
2353         p->state = UNUSED;
2354         release(&ptable.lock);
2355         return pid;
2356       }
2357     }
2358 
2359     
2360     if(!havekids || proc->killed){
2361       release(&ptable.lock);
2362       return -1;
2363     }
2364 
2365     
2366     sleep(proc, &ptable.lock);  
2367   }
2368 }
2369 
2370 
2371 
2372 
2373 
2374 
2375 
2376 
2377 void
2378 scheduler(void)
2379 {
2380   struct proc *p;
2381 
2382   for(;;){
2383     
2384     sti();
2385 
2386     
2387     acquire(&ptable.lock);
2388     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2389       if(p->state != RUNNABLE)
2390         continue;
2391 
2392       
2393       
2394       
2395       proc = p;
2396       switchuvm(p);
2397       p->state = RUNNING;
2398       swtch(&cpu->scheduler, p->context);
2399       switchkvm();
2400       
2401       
2402       proc = 0;
2403     }
2404     release(&ptable.lock);
2405 
2406   }
2407 }
2408 
2409 
2410 
2411 
2412 
2413 
2414 
2415 
2416 void
2417 sched(void)
2418 {
2419   int intena;
2420 
2421   if(!holding(&ptable.lock))
2422     panic("sched ptable.lock");
2423   if(cpu->ncli != 1)
2424     panic("sched locks");
2425   if(proc->state == RUNNING)
2426     panic("sched running");
2427   if(readeflags()&FL_IF)
2428     panic("sched interruptible");
2429   intena = cpu->intena;
2430   swtch(&proc->context, cpu->scheduler);
2431   cpu->intena = intena;
2432 }
2433 
2434 
2435 void
2436 yield(void)
2437 {
2438   acquire(&ptable.lock);  
2439   proc->state = RUNNABLE;
2440   sched();
2441   release(&ptable.lock);
2442 }
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 
2452 void
2453 forkret(void)
2454 {
2455   static int first = 1;
2456   
2457   release(&ptable.lock);
2458 
2459   if (first) {
2460     
2461     
2462     
2463     first = 0;
2464     iinit(ROOTDEV);
2465     initlog(ROOTDEV);
2466   }
2467 
2468   
2469 }
2470 
2471 
2472 
2473 void
2474 sleep(void *chan, struct spinlock *lk)
2475 {
2476   if(proc == 0)
2477     panic("sleep");
2478 
2479   if(lk == 0)
2480     panic("sleep without lk");
2481 
2482   
2483   
2484   
2485   
2486   
2487   
2488   if(lk != &ptable.lock){  
2489     acquire(&ptable.lock);  
2490     release(lk);
2491   }
2492 
2493   
2494   proc->chan = chan;
2495   proc->state = SLEEPING;
2496   sched();
2497 
2498   
2499   proc->chan = 0;
2500   
2501   if(lk != &ptable.lock){  
2502     release(&ptable.lock);
2503     acquire(lk);
2504   }
2505 }
2506 
2507 
2508 
2509 static void
2510 wakeup1(void *chan)
2511 {
2512   struct proc *p;
2513 
2514   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2515     if(p->state == SLEEPING && p->chan == chan)
2516       p->state = RUNNABLE;
2517 }
2518 
2519 
2520 void
2521 wakeup(void *chan)
2522 {
2523   acquire(&ptable.lock);
2524   wakeup1(chan);
2525   release(&ptable.lock);
2526 }
2527 
2528 
2529 
2530 
2531 int
2532 kill(int pid)
2533 {
2534   struct proc *p;
2535 
2536   acquire(&ptable.lock);
2537   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2538     if(p->pid == pid){
2539       p->killed = 1;
2540       
2541       if(p->state == SLEEPING)
2542         p->state = RUNNABLE;
2543       release(&ptable.lock);
2544       return 0;
2545     }
2546   }
2547   release(&ptable.lock);
2548   return -1;
2549 }
2550 
2551 
2552 
2553 void
2554 procdump(void)
2555 {
2556   static char *states[] = {
2557   [UNUSED]    "unused",
2558   [EMBRYO]    "embryo",
2559   [SLEEPING]  "sleep ",
2560   [RUNNABLE]  "runble",
2561   [RUNNING]   "run   ",
2562   [ZOMBIE]    "zombie"
2563   };
2564   int i;
2565   struct proc *p;
2566   char *state;
2567   uint pc[10];
2568 
2569   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2570     if(p->state == UNUSED)
2571       continue;
2572     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
2573       state = states[p->state];
2574     else
2575       state = "???";
2576     cprintf("%d %s %s", p->pid, state, p->name);
2577     if(p->state == SLEEPING){
2578       getcallerpcs((uint*)p->context->ebp+2, pc);
2579       for(i=0; i<10 && pc[i] != 0; i++)
2580         cprintf(" %p", pc[i]);
2581     }
2582     cprintf("\n");
2583   }
2584 }
2585 
2586 
2587 
2588 
2589 
2590 
2591 
2592 
2593 
2594 
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602 
2603 
2604 
2605 
2606 
2607 .globl swtch
2608 swtch:
2609   movl 4(%esp), %eax
2610   movl 8(%esp), %edx
2611 
2612   
2613   pushl %ebp
2614   pushl %ebx
2615   pushl %esi
2616   pushl %edi
2617 
2618   
2619   movl %esp, (%eax)
2620   movl %edx, %esp
2621 
2622   
2623   popl %edi
2624   popl %esi
2625   popl %ebx
2626   popl %ebp
2627   ret
2628 
2629 
2630 
2631 
2632 
2633 
2634 
2635 
2636 
2637 
2638 
2639 
2640 
2641 
2642 
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 
2654 #include "types.h"
2655 #include "defs.h"
2656 #include "param.h"
2657 #include "memlayout.h"
2658 #include "mmu.h"
2659 #include "spinlock.h"
2660 
2661 void freerange(void *vstart, void *vend);
2662 extern char end[]; 
2663 
2664 struct run {
2665   struct run *next;
2666 };
2667 
2668 struct {
2669   struct spinlock lock;
2670   int use_lock;
2671   struct run *freelist;
2672 } kmem;
2673 
2674 
2675 
2676 
2677 
2678 
2679 void
2680 kinit1(void *vstart, void *vend)
2681 {
2682   initlock(&kmem.lock, "kmem");
2683   kmem.use_lock = 0;
2684   freerange(vstart, vend);
2685 }
2686 
2687 void
2688 kinit2(void *vstart, void *vend)
2689 {
2690   freerange(vstart, vend);
2691   kmem.use_lock = 1;
2692 }
2693 
2694 
2695 
2696 
2697 
2698 
2699 
2700 void
2701 freerange(void *vstart, void *vend)
2702 {
2703   char *p;
2704   p = (char*)PGROUNDUP((uint)vstart);
2705   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
2706     kfree(p);
2707 }
2708 
2709 
2710 
2711 
2712 
2713 void
2714 kfree(char *v)
2715 {
2716   struct run *r;
2717 
2718   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
2719     panic("kfree");
2720 
2721   
2722   memset(v, 1, PGSIZE);
2723 
2724   if(kmem.use_lock)
2725     acquire(&kmem.lock);
2726   r = (struct run*)v;
2727   r->next = kmem.freelist;
2728   kmem.freelist = r;
2729   if(kmem.use_lock)
2730     release(&kmem.lock);
2731 }
2732 
2733 
2734 
2735 
2736 char*
2737 kalloc(void)
2738 {
2739   struct run *r;
2740 
2741   if(kmem.use_lock)
2742     acquire(&kmem.lock);
2743   r = kmem.freelist;
2744   if(r)
2745     kmem.freelist = r->next;
2746   if(kmem.use_lock)
2747     release(&kmem.lock);
2748   return (char*)r;
2749 }
2750 
2751 
2752 
2753 #define T_DIVIDE         0      
2754 #define T_DEBUG          1      
2755 #define T_NMI            2      
2756 #define T_BRKPT          3      
2757 #define T_OFLOW          4      
2758 #define T_BOUND          5      
2759 #define T_ILLOP          6      
2760 #define T_DEVICE         7      
2761 #define T_DBLFLT         8      
2762 
2763 #define T_TSS           10      
2764 #define T_SEGNP         11      
2765 #define T_STACK         12      
2766 #define T_GPFLT         13      
2767 #define T_PGFLT         14      
2768 
2769 #define T_FPERR         16      
2770 #define T_ALIGN         17      
2771 #define T_MCHK          18      
2772 #define T_SIMDERR       19      
2773 
2774 
2775 
2776 #define T_SYSCALL       64      
2777 #define T_DEFAULT      500      
2778 
2779 #define T_IRQ0          32      
2780 
2781 #define IRQ_TIMER        0
2782 #define IRQ_KBD          1
2783 #define IRQ_COM1         4
2784 #define IRQ_IDE         14
2785 #define IRQ_ERROR       19
2786 #define IRQ_SPURIOUS    31
2787 
2788 
2789 
2790 
2791 
2792 
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 #!/usr/bin/perl -w
2801 
2802 # Generate vectors.S, the trap/interrupt entry points.
2803 # There has to be one entry point per interrupt number
2804 # since otherwise there's no way for trap() to discover
2805 # the interrupt number.
2806 
2807 print "# generated by vectors.pl - do not edit\n";
2808 print "# handlers\n";
2809 print ".globl alltraps\n";
2810 for(my $i = 0; $i < 256; $i++){
2811     print ".globl vector$i\n";
2812     print "vector$i:\n";
2813     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
2814         print "  pushl \$0\n";
2815     }
2816     print "  pushl \$$i\n";
2817     print "  jmp alltraps\n";
2818 }
2819 
2820 print "\n# vector table\n";
2821 print ".data\n";
2822 print ".globl vectors\n";
2823 print "vectors:\n";
2824 for(my $i = 0; $i < 256; $i++){
2825     print "  .long vector$i\n";
2826 }
2827 
2828 # sample output:
2829 #   # handlers
2830 #   .globl alltraps
2831 #   .globl vector0
2832 #   vector0:
2833 #     pushl $0
2834 #     pushl $0
2835 #     jmp alltraps
2836 #   ...
2837 #
2838 #   # vector table
2839 #   .data
2840 #   .globl vectors
2841 #   vectors:
2842 #     .long vector0
2843 #     .long vector1
2844 #     .long vector2
2845 #   ...
2846 
2847 
2848 
2849 
2850 
2851 
2852   
2853 .globl alltraps
2854 alltraps:
2855   
2856   pushl %ds
2857   pushl %es
2858   pushl %fs
2859   pushl %gs
2860   pushal
2861 
2862   
2863   movw $(SEG_KDATA<<3), %ax
2864   movw %ax, %ds
2865   movw %ax, %es
2866   movw $(SEG_KCPU<<3), %ax
2867   movw %ax, %fs
2868   movw %ax, %gs
2869 
2870   
2871   pushl %esp
2872   call trap
2873   addl $4, %esp
2874 
2875   
2876 .globl trapret
2877 trapret:
2878   popal
2879   popl %gs
2880   popl %fs
2881   popl %es
2882   popl %ds
2883   addl $0x8, %esp  
2884   iret
2885 
2886 
2887 
2888 
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 #include "types.h"
2901 #include "defs.h"
2902 #include "param.h"
2903 #include "memlayout.h"
2904 #include "mmu.h"
2905 #include "proc.h"
2906 #include "x86.h"
2907 #include "traps.h"
2908 #include "spinlock.h"
2909 
2910 
2911 struct gatedesc idt[256];
2912 extern uint vectors[];  
2913 struct spinlock tickslock;
2914 uint ticks;
2915 
2916 void
2917 tvinit(void)
2918 {
2919   int i;
2920 
2921   for(i = 0; i < 256; i++)
2922     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
2923   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
2924 
2925   initlock(&tickslock, "time");
2926 }
2927 
2928 void
2929 idtinit(void)
2930 {
2931   lidt(idt, sizeof(idt));
2932 }
2933 
2934 void
2935 trap(struct trapframe *tf)
2936 {
2937   if(tf->trapno == T_SYSCALL){
2938     if(proc->killed)
2939       exit();
2940     proc->tf = tf;
2941     syscall();
2942     if(proc->killed)
2943       exit();
2944     return;
2945   }
2946 
2947   switch(tf->trapno){
2948   case T_IRQ0 + IRQ_TIMER:
2949     if(cpunum() == 0){
2950       acquire(&tickslock);
2951       ticks++;
2952       wakeup(&ticks);
2953       release(&tickslock);
2954     }
2955     lapiceoi();
2956     break;
2957   case T_IRQ0 + IRQ_IDE:
2958     ideintr();
2959     lapiceoi();
2960     break;
2961   case T_IRQ0 + IRQ_IDE+1:
2962     
2963     break;
2964   case T_IRQ0 + IRQ_KBD:
2965     kbdintr();
2966     lapiceoi();
2967     break;
2968   case T_IRQ0 + IRQ_COM1:
2969     uartintr();
2970     lapiceoi();
2971     break;
2972   case T_IRQ0 + 7:
2973   case T_IRQ0 + IRQ_SPURIOUS:
2974     cprintf("cpu%d: spurious interrupt at %x:%x\n",
2975             cpunum(), tf->cs, tf->eip);
2976     lapiceoi();
2977     break;
2978 
2979   default:
2980     if(proc == 0 || (tf->cs&3) == 0){
2981       
2982       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
2983               tf->trapno, cpunum(), tf->eip, rcr2());
2984       panic("trap");
2985     }
2986     
2987     cprintf("pid %d %s: trap %d err %d on cpu %d "
2988             "eip 0x%x addr 0x%x--kill proc\n",
2989             proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
2990             rcr2());
2991     proc->killed = 1;
2992   }
2993 
2994   
2995   
2996   
2997   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
2998     exit();
2999 
3000   
3001   
3002   if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
3003     yield();
3004 
3005   
3006   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3007     exit();
3008 }
3009 
3010 
3011 
3012 
3013 
3014 
3015 
3016 
3017 
3018 
3019 
3020 
3021 
3022 
3023 
3024 
3025 
3026 
3027 
3028 
3029 
3030 
3031 
3032 
3033 
3034 
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 #define SYS_fork    1
3052 #define SYS_exit    2
3053 #define SYS_wait    3
3054 #define SYS_pipe    4
3055 #define SYS_read    5
3056 #define SYS_kill    6
3057 #define SYS_exec    7
3058 #define SYS_fstat   8
3059 #define SYS_chdir   9
3060 #define SYS_dup    10
3061 #define SYS_getpid 11
3062 #define SYS_sbrk   12
3063 #define SYS_sleep  13
3064 #define SYS_uptime 14
3065 #define SYS_open   15
3066 #define SYS_write  16
3067 #define SYS_mknod  17
3068 #define SYS_unlink 18
3069 #define SYS_link   19
3070 #define SYS_mkdir  20
3071 #define SYS_close  21
3072 
3073 
3074 
3075 
3076 
3077 
3078 
3079 
3080 
3081 
3082 
3083 
3084 
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 #include "types.h"
3101 #include "defs.h"
3102 #include "param.h"
3103 #include "memlayout.h"
3104 #include "mmu.h"
3105 #include "proc.h"
3106 #include "x86.h"
3107 #include "syscall.h"
3108 
3109 
3110 
3111 
3112 
3113 
3114 
3115 
3116 int
3117 fetchint(uint addr, int *ip)
3118 {
3119   if(addr >= proc->sz || addr+4 > proc->sz)
3120     return -1;
3121   *ip = *(int*)(addr);
3122   return 0;
3123 }
3124 
3125 
3126 
3127 
3128 int
3129 fetchstr(uint addr, char **pp)
3130 {
3131   char *s, *ep;
3132 
3133   if(addr >= proc->sz)
3134     return -1;
3135   *pp = (char*)addr;
3136   ep = (char*)proc->sz;
3137   for(s = *pp; s < ep; s++)
3138     if(*s == 0)
3139       return s - *pp;
3140   return -1;
3141 }
3142 
3143 
3144 int
3145 argint(int n, int *ip)
3146 {
3147   return fetchint(proc->tf->esp + 4 + 4*n, ip);
3148 }
3149 
3150 
3151 
3152 
3153 int
3154 argptr(int n, char **pp, int size)
3155 {
3156   int i;
3157 
3158   if(argint(n, &i) < 0)
3159     return -1;
3160   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
3161     return -1;
3162   *pp = (char*)i;
3163   return 0;
3164 }
3165 
3166 
3167 
3168 
3169 
3170 int
3171 argstr(int n, char **pp)
3172 {
3173   int addr;
3174   if(argint(n, &addr) < 0)
3175     return -1;
3176   return fetchstr(addr, pp);
3177 }
3178 
3179 extern int sys_chdir(void);
3180 extern int sys_close(void);
3181 extern int sys_dup(void);
3182 extern int sys_exec(void);
3183 extern int sys_exit(void);
3184 extern int sys_fork(void);
3185 extern int sys_fstat(void);
3186 extern int sys_getpid(void);
3187 extern int sys_kill(void);
3188 extern int sys_link(void);
3189 extern int sys_mkdir(void);
3190 extern int sys_mknod(void);
3191 extern int sys_open(void);
3192 extern int sys_pipe(void);
3193 extern int sys_read(void);
3194 extern int sys_sbrk(void);
3195 extern int sys_sleep(void);
3196 extern int sys_unlink(void);
3197 extern int sys_wait(void);
3198 extern int sys_write(void);
3199 extern int sys_uptime(void);
3200 static int (*syscalls[])(void) = {
3201 [SYS_fork]    sys_fork,
3202 [SYS_exit]    sys_exit,
3203 [SYS_wait]    sys_wait,
3204 [SYS_pipe]    sys_pipe,
3205 [SYS_read]    sys_read,
3206 [SYS_kill]    sys_kill,
3207 [SYS_exec]    sys_exec,
3208 [SYS_fstat]   sys_fstat,
3209 [SYS_chdir]   sys_chdir,
3210 [SYS_dup]     sys_dup,
3211 [SYS_getpid]  sys_getpid,
3212 [SYS_sbrk]    sys_sbrk,
3213 [SYS_sleep]   sys_sleep,
3214 [SYS_uptime]  sys_uptime,
3215 [SYS_open]    sys_open,
3216 [SYS_write]   sys_write,
3217 [SYS_mknod]   sys_mknod,
3218 [SYS_unlink]  sys_unlink,
3219 [SYS_link]    sys_link,
3220 [SYS_mkdir]   sys_mkdir,
3221 [SYS_close]   sys_close,
3222 };
3223 
3224 void
3225 syscall(void)
3226 {
3227   int num;
3228 
3229   num = proc->tf->eax;
3230   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3231     proc->tf->eax = syscalls[num]();
3232   } else {
3233     cprintf("%d %s: unknown sys call %d\n",
3234             proc->pid, proc->name, num);
3235     proc->tf->eax = -1;
3236   }
3237 }
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 #include "types.h"
3251 #include "x86.h"
3252 #include "defs.h"
3253 #include "date.h"
3254 #include "param.h"
3255 #include "memlayout.h"
3256 #include "mmu.h"
3257 #include "proc.h"
3258 
3259 int
3260 sys_fork(void)
3261 {
3262   return fork();
3263 }
3264 
3265 int
3266 sys_exit(void)
3267 {
3268   exit();
3269   return 0;  
3270 }
3271 
3272 int
3273 sys_wait(void)
3274 {
3275   return wait();
3276 }
3277 
3278 int
3279 sys_kill(void)
3280 {
3281   int pid;
3282 
3283   if(argint(0, &pid) < 0)
3284     return -1;
3285   return kill(pid);
3286 }
3287 
3288 int
3289 sys_getpid(void)
3290 {
3291   return proc->pid;
3292 }
3293 
3294 
3295 
3296 
3297 
3298 
3299 
3300 int
3301 sys_sbrk(void)
3302 {
3303   int addr;
3304   int n;
3305 
3306   if(argint(0, &n) < 0)
3307     return -1;
3308   addr = proc->sz;
3309   if(growproc(n) < 0)
3310     return -1;
3311   return addr;
3312 }
3313 
3314 int
3315 sys_sleep(void)
3316 {
3317   int n;
3318   uint ticks0;
3319 
3320   if(argint(0, &n) < 0)
3321     return -1;
3322   acquire(&tickslock);
3323   ticks0 = ticks;
3324   while(ticks - ticks0 < n){
3325     if(proc->killed){
3326       release(&tickslock);
3327       return -1;
3328     }
3329     sleep(&ticks, &tickslock);
3330   }
3331   release(&tickslock);
3332   return 0;
3333 }
3334 
3335 
3336 
3337 int
3338 sys_uptime(void)
3339 {
3340   uint xticks;
3341 
3342   acquire(&tickslock);
3343   xticks = ticks;
3344   release(&tickslock);
3345   return xticks;
3346 }
3347 
3348 
3349 
3350 struct buf {
3351   int flags;
3352   uint dev;
3353   uint blockno;
3354   struct sleeplock lock;
3355   uint refcnt;
3356   struct buf *prev; 
3357   struct buf *next;
3358   struct buf *qnext; 
3359   uchar data[BSIZE];
3360 };
3361 #define B_VALID 0x2  
3362 #define B_DIRTY 0x4  
3363 
3364 
3365 
3366 
3367 
3368 
3369 
3370 
3371 
3372 
3373 
3374 
3375 
3376 
3377 
3378 
3379 
3380 
3381 
3382 
3383 
3384 
3385 
3386 
3387 
3388 
3389 
3390 
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 
3401 struct sleeplock {
3402   uint locked;       
3403   struct spinlock lk; 
3404 
3405   
3406   char *name;        
3407   int pid;           
3408 };
3409 
3410 
3411 
3412 
3413 
3414 
3415 
3416 
3417 
3418 
3419 
3420 
3421 
3422 
3423 
3424 
3425 
3426 
3427 
3428 
3429 
3430 
3431 
3432 
3433 
3434 
3435 
3436 
3437 
3438 
3439 
3440 
3441 
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 #define O_RDONLY  0x000
3451 #define O_WRONLY  0x001
3452 #define O_RDWR    0x002
3453 #define O_CREATE  0x200
3454 
3455 
3456 
3457 
3458 
3459 
3460 
3461 
3462 
3463 
3464 
3465 
3466 
3467 
3468 
3469 
3470 
3471 
3472 
3473 
3474 
3475 
3476 
3477 
3478 
3479 
3480 
3481 
3482 
3483 
3484 
3485 
3486 
3487 
3488 
3489 
3490 
3491 
3492 
3493 
3494 
3495 
3496 
3497 
3498 
3499 
3500 #define T_DIR  1   
3501 #define T_FILE 2   
3502 #define T_DEV  3   
3503 
3504 struct stat {
3505   short type;  
3506   int dev;     
3507   uint ino;    
3508   short nlink; 
3509   uint size;   
3510 };
3511 
3512 
3513 
3514 
3515 
3516 
3517 
3518 
3519 
3520 
3521 
3522 
3523 
3524 
3525 
3526 
3527 
3528 
3529 
3530 
3531 
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 
3551 
3552 
3553 
3554 #define ROOTINO 1  
3555 #define BSIZE 512  
3556 
3557 
3558 
3559 
3560 
3561 
3562 
3563 struct superblock {
3564   uint size;         
3565   uint nblocks;      
3566   uint ninodes;      
3567   uint nlog;         
3568   uint logstart;     
3569   uint inodestart;   
3570   uint bmapstart;    
3571 };
3572 
3573 #define NDIRECT 12
3574 #define NINDIRECT (BSIZE / sizeof(uint))
3575 #define MAXFILE (NDIRECT + NINDIRECT)
3576 
3577 
3578 struct dinode {
3579   short type;           
3580   short major;          
3581   short minor;          
3582   short nlink;          
3583   uint size;            
3584   uint addrs[NDIRECT+1];   
3585 };
3586 
3587 
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 
3601 #define IPB           (BSIZE / sizeof(struct dinode))
3602 
3603 
3604 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
3605 
3606 
3607 #define BPB           (BSIZE*8)
3608 
3609 
3610 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
3611 
3612 
3613 #define DIRSIZ 14
3614 
3615 struct dirent {
3616   ushort inum;
3617   char name[DIRSIZ];
3618 };
3619 
3620 
3621 
3622 
3623 
3624 
3625 
3626 
3627 
3628 
3629 
3630 
3631 
3632 
3633 
3634 
3635 
3636 
3637 
3638 
3639 
3640 
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 struct file {
3651   enum { FD_NONE, FD_PIPE, FD_INODE } type;
3652   int ref; 
3653   char readable;
3654   char writable;
3655   struct pipe *pipe;
3656   struct inode *ip;
3657   uint off;
3658 };
3659 
3660 
3661 
3662 struct inode {
3663   uint dev;           
3664   uint inum;          
3665   int ref;            
3666   struct sleeplock lock;
3667   int flags;          
3668 
3669   short type;         
3670   short major;
3671   short minor;
3672   short nlink;
3673   uint size;
3674   uint addrs[NDIRECT+1];
3675 };
3676 #define I_VALID 0x2
3677 
3678 
3679 
3680 struct devsw {
3681   int (*read)(struct inode*, char*, int);
3682   int (*write)(struct inode*, char*, int);
3683 };
3684 
3685 extern struct devsw devsw[];
3686 
3687 #define CONSOLE 1
3688 
3689 
3690 
3691 
3692 
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 
3701 
3702 #include "types.h"
3703 #include "defs.h"
3704 #include "param.h"
3705 #include "memlayout.h"
3706 #include "mmu.h"
3707 #include "proc.h"
3708 #include "x86.h"
3709 #include "traps.h"
3710 #include "spinlock.h"
3711 #include "sleeplock.h"
3712 #include "fs.h"
3713 #include "buf.h"
3714 
3715 #define SECTOR_SIZE   512
3716 #define IDE_BSY       0x80
3717 #define IDE_DRDY      0x40
3718 #define IDE_DF        0x20
3719 #define IDE_ERR       0x01
3720 
3721 #define IDE_CMD_READ  0x20
3722 #define IDE_CMD_WRITE 0x30
3723 #define IDE_CMD_RDMUL 0xc4
3724 #define IDE_CMD_WRMUL 0xc5
3725 
3726 
3727 
3728 
3729 
3730 static struct spinlock idelock;
3731 static struct buf *idequeue;
3732 
3733 static int havedisk1;
3734 static void idestart(struct buf*);
3735 
3736 
3737 static int
3738 idewait(int checkerr)
3739 {
3740   int r;
3741 
3742   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
3743     ;
3744   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
3745     return -1;
3746   return 0;
3747 }
3748 
3749 
3750 void
3751 ideinit(void)
3752 {
3753   int i;
3754 
3755   initlock(&idelock, "ide");
3756   picenable(IRQ_IDE);
3757   ioapicenable(IRQ_IDE, ncpu - 1);
3758   idewait(0);
3759 
3760   
3761   outb(0x1f6, 0xe0 | (1<<4));
3762   for(i=0; i<1000; i++){
3763     if(inb(0x1f7) != 0){
3764       havedisk1 = 1;
3765       break;
3766     }
3767   }
3768 
3769   
3770   outb(0x1f6, 0xe0 | (0<<4));
3771 }
3772 
3773 
3774 static void
3775 idestart(struct buf *b)
3776 {
3777   if(b == 0)
3778     panic("idestart");
3779   if(b->blockno >= FSSIZE)
3780     panic("incorrect blockno");
3781   int sector_per_block =  BSIZE/SECTOR_SIZE;
3782   int sector = b->blockno * sector_per_block;
3783   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
3784   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
3785 
3786   if (sector_per_block > 7) panic("idestart");
3787 
3788   idewait(0);
3789   outb(0x3f6, 0);  
3790   outb(0x1f2, sector_per_block);  
3791   outb(0x1f3, sector & 0xff);
3792   outb(0x1f4, (sector >> 8) & 0xff);
3793   outb(0x1f5, (sector >> 16) & 0xff);
3794   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
3795   if(b->flags & B_DIRTY){
3796     outb(0x1f7, write_cmd);
3797     outsl(0x1f0, b->data, BSIZE/4);
3798   } else {
3799     outb(0x1f7, read_cmd);
3800   }
3801 }
3802 
3803 
3804 void
3805 ideintr(void)
3806 {
3807   struct buf *b;
3808 
3809   
3810   acquire(&idelock);
3811   if((b = idequeue) == 0){
3812     release(&idelock);
3813     
3814     return;
3815   }
3816   idequeue = b->qnext;
3817 
3818   
3819   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
3820     insl(0x1f0, b->data, BSIZE/4);
3821 
3822   
3823   b->flags |= B_VALID;
3824   b->flags &= ~B_DIRTY;
3825   wakeup(b);
3826 
3827   
3828   if(idequeue != 0)
3829     idestart(idequeue);
3830 
3831   release(&idelock);
3832 }
3833 
3834 
3835 
3836 
3837 void
3838 iderw(struct buf *b)
3839 {
3840   struct buf **pp;
3841 
3842   if(!holdingsleep(&b->lock))
3843     panic("iderw: buf not locked");
3844   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
3845     panic("iderw: nothing to do");
3846   if(b->dev != 0 && !havedisk1)
3847     panic("iderw: ide disk 1 not present");
3848 
3849   acquire(&idelock);  
3850   
3851   b->qnext = 0;
3852   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
3853     ;
3854   *pp = b;
3855 
3856   
3857   if(idequeue == b)
3858     idestart(b);
3859 
3860   
3861   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
3862     sleep(b, &idelock);
3863   }
3864 
3865   release(&idelock);
3866 }
3867 
3868 
3869 
3870 
3871 
3872 
3873 
3874 
3875 
3876 
3877 
3878 
3879 
3880 
3881 
3882 
3883 
3884 
3885 
3886 
3887 
3888 
3889 
3890 
3891 
3892 
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 
3901 
3902 
3903 
3904 
3905 
3906 
3907 
3908 
3909 
3910 
3911 
3912 
3913 
3914 
3915 
3916 
3917 
3918 
3919 
3920 #include "types.h"
3921 #include "defs.h"
3922 #include "param.h"
3923 #include "spinlock.h"
3924 #include "sleeplock.h"
3925 #include "fs.h"
3926 #include "buf.h"
3927 
3928 struct {
3929   struct spinlock lock;
3930   struct buf buf[NBUF];
3931 
3932   
3933   
3934   struct buf head;
3935 } bcache;
3936 
3937 void
3938 binit(void)
3939 {
3940   struct buf *b;
3941 
3942   initlock(&bcache.lock, "bcache");
3943 
3944   
3945   bcache.head.prev = &bcache.head;
3946   bcache.head.next = &bcache.head;
3947   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
3948     b->next = bcache.head.next;
3949     b->prev = &bcache.head;
3950     initsleeplock(&b->lock, "buffer");
3951     bcache.head.next->prev = b;
3952     bcache.head.next = b;
3953   }
3954 }
3955 
3956 
3957 
3958 
3959 static struct buf*
3960 bget(uint dev, uint blockno)
3961 {
3962   struct buf *b;
3963 
3964   acquire(&bcache.lock);
3965 
3966   
3967   for(b = bcache.head.next; b != &bcache.head; b = b->next){
3968     if(b->dev == dev && b->blockno == blockno){
3969       b->refcnt++;
3970       release(&bcache.lock);
3971       acquiresleep(&b->lock);
3972       return b;
3973     }
3974   }
3975 
3976   
3977   
3978   
3979   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
3980     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
3981       b->dev = dev;
3982       b->blockno = blockno;
3983       b->flags = 0;
3984       b->refcnt = 1;
3985       release(&bcache.lock);
3986       acquiresleep(&b->lock);
3987       return b;
3988     }
3989   }
3990   panic("bget: no buffers");
3991 }
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 struct buf*
4002 bread(uint dev, uint blockno)
4003 {
4004   struct buf *b;
4005 
4006   b = bget(dev, blockno);
4007   if(!(b->flags & B_VALID)) {
4008     iderw(b);
4009   }
4010   return b;
4011 }
4012 
4013 
4014 void
4015 bwrite(struct buf *b)
4016 {
4017   if(!holdingsleep(&b->lock))
4018     panic("bwrite");
4019   b->flags |= B_DIRTY;
4020   iderw(b);
4021 }
4022 
4023 
4024 
4025 void
4026 brelse(struct buf *b)
4027 {
4028   if(!holdingsleep(&b->lock))
4029     panic("brelse");
4030 
4031   releasesleep(&b->lock);
4032 
4033   acquire(&bcache.lock);
4034   b->refcnt--;
4035   if (b->refcnt == 0) {
4036     
4037     b->next->prev = b->prev;
4038     b->prev->next = b->next;
4039     b->next = bcache.head.next;
4040     b->prev = &bcache.head;
4041     bcache.head.next->prev = b;
4042     bcache.head.next = b;
4043   }
4044 
4045   release(&bcache.lock);
4046 }
4047 
4048 
4049 
4050 
4051 
4052 #include "types.h"
4053 #include "defs.h"
4054 #include "param.h"
4055 #include "x86.h"
4056 #include "memlayout.h"
4057 #include "mmu.h"
4058 #include "proc.h"
4059 #include "spinlock.h"
4060 #include "sleeplock.h"
4061 
4062 void
4063 initsleeplock(struct sleeplock *lk, char *name)
4064 {
4065   initlock(&lk->lk, "sleep lock");
4066   lk->name = name;
4067   lk->locked = 0;
4068   lk->pid = 0;
4069 }
4070 
4071 void
4072 acquiresleep(struct sleeplock *lk)
4073 {
4074   acquire(&lk->lk);
4075   while (lk->locked) {
4076     sleep(lk, &lk->lk);
4077   }
4078   lk->locked = 1;
4079   lk->pid = proc->pid;
4080   release(&lk->lk);
4081 }
4082 
4083 void
4084 releasesleep(struct sleeplock *lk)
4085 {
4086   acquire(&lk->lk);
4087   lk->locked = 0;
4088   lk->pid = 0;
4089   wakeup(lk);
4090   release(&lk->lk);
4091 }
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 int
4101 holdingsleep(struct sleeplock *lk)
4102 {
4103   int r;
4104 
4105   acquire(&lk->lk);
4106   r = lk->locked;
4107   release(&lk->lk);
4108   return r;
4109 }
4110 
4111 
4112 
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 
4123 
4124 
4125 
4126 
4127 
4128 
4129 
4130 
4131 
4132 
4133 
4134 
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 #include "types.h"
4151 #include "defs.h"
4152 #include "param.h"
4153 #include "spinlock.h"
4154 #include "sleeplock.h"
4155 #include "fs.h"
4156 #include "buf.h"
4157 
4158 
4159 
4160 
4161 
4162 
4163 
4164 
4165 
4166 
4167 
4168 
4169 
4170 
4171 
4172 
4173 
4174 
4175 
4176 
4177 
4178 
4179 
4180 
4181 
4182 
4183 struct logheader {
4184   int n;
4185   int block[LOGSIZE];
4186 };
4187 
4188 struct log {
4189   struct spinlock lock;
4190   int start;
4191   int size;
4192   int outstanding; 
4193   int committing;  
4194   int dev;
4195   struct logheader lh;
4196 };
4197 
4198 
4199 
4200 struct log log;
4201 
4202 static void recover_from_log(void);
4203 static void commit();
4204 
4205 void
4206 initlog(int dev)
4207 {
4208   if (sizeof(struct logheader) >= BSIZE)
4209     panic("initlog: too big logheader");
4210 
4211   struct superblock sb;
4212   initlock(&log.lock, "log");
4213   readsb(dev, &sb);
4214   log.start = sb.logstart;
4215   log.size = sb.nlog;
4216   log.dev = dev;
4217   recover_from_log();
4218 }
4219 
4220 
4221 static void
4222 install_trans(void)
4223 {
4224   int tail;
4225 
4226   for (tail = 0; tail < log.lh.n; tail++) {
4227     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4228     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4229     memmove(dbuf->data, lbuf->data, BSIZE);  
4230     bwrite(dbuf);  
4231     brelse(lbuf);
4232     brelse(dbuf);
4233   }
4234 }
4235 
4236 
4237 static void
4238 read_head(void)
4239 {
4240   struct buf *buf = bread(log.dev, log.start);
4241   struct logheader *lh = (struct logheader *) (buf->data);
4242   int i;
4243   log.lh.n = lh->n;
4244   for (i = 0; i < log.lh.n; i++) {
4245     log.lh.block[i] = lh->block[i];
4246   }
4247   brelse(buf);
4248 }
4249 
4250 
4251 
4252 
4253 static void
4254 write_head(void)
4255 {
4256   struct buf *buf = bread(log.dev, log.start);
4257   struct logheader *hb = (struct logheader *) (buf->data);
4258   int i;
4259   hb->n = log.lh.n;
4260   for (i = 0; i < log.lh.n; i++) {
4261     hb->block[i] = log.lh.block[i];
4262   }
4263   bwrite(buf);
4264   brelse(buf);
4265 }
4266 
4267 static void
4268 recover_from_log(void)
4269 {
4270   read_head();
4271   install_trans(); 
4272   log.lh.n = 0;
4273   write_head(); 
4274 }
4275 
4276 
4277 void
4278 begin_op(void)
4279 {
4280   acquire(&log.lock);
4281   while(1){
4282     if(log.committing){
4283       sleep(&log, &log.lock);
4284     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4285       
4286       sleep(&log, &log.lock);
4287     } else {
4288       log.outstanding += 1;
4289       release(&log.lock);
4290       break;
4291     }
4292   }
4293 }
4294 
4295 
4296 
4297 
4298 
4299 
4300 
4301 
4302 void
4303 end_op(void)
4304 {
4305   int do_commit = 0;
4306 
4307   acquire(&log.lock);
4308   log.outstanding -= 1;
4309   if(log.committing)
4310     panic("log.committing");
4311   if(log.outstanding == 0){
4312     do_commit = 1;
4313     log.committing = 1;
4314   } else {
4315     
4316     wakeup(&log);
4317   }
4318   release(&log.lock);
4319 
4320   if(do_commit){
4321     
4322     
4323     commit();
4324     acquire(&log.lock);
4325     log.committing = 0;
4326     wakeup(&log);
4327     release(&log.lock);
4328   }
4329 }
4330 
4331 
4332 static void
4333 write_log(void)
4334 {
4335   int tail;
4336 
4337   for (tail = 0; tail < log.lh.n; tail++) {
4338     struct buf *to = bread(log.dev, log.start+tail+1); 
4339     struct buf *from = bread(log.dev, log.lh.block[tail]); 
4340     memmove(to->data, from->data, BSIZE);
4341     bwrite(to);  
4342     brelse(from);
4343     brelse(to);
4344   }
4345 }
4346 
4347 
4348 
4349 
4350 static void
4351 commit()
4352 {
4353   if (log.lh.n > 0) {
4354     write_log();     
4355     write_head();    
4356     install_trans(); 
4357     log.lh.n = 0;
4358     write_head();    
4359   }
4360 }
4361 
4362 
4363 
4364 
4365 
4366 
4367 
4368 
4369 
4370 
4371 void
4372 log_write(struct buf *b)
4373 {
4374   int i;
4375 
4376   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
4377     panic("too big a transaction");
4378   if (log.outstanding < 1)
4379     panic("log_write outside of trans");
4380 
4381   acquire(&log.lock);
4382   for (i = 0; i < log.lh.n; i++) {
4383     if (log.lh.block[i] == b->blockno)   
4384       break;
4385   }
4386   log.lh.block[i] = b->blockno;
4387   if (i == log.lh.n)
4388     log.lh.n++;
4389   b->flags |= B_DIRTY; 
4390   release(&log.lock);
4391 }
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 
4401 
4402 
4403 
4404 
4405 
4406 
4407 
4408 
4409 
4410 
4411 #include "types.h"
4412 #include "defs.h"
4413 #include "param.h"
4414 #include "stat.h"
4415 #include "mmu.h"
4416 #include "proc.h"
4417 #include "spinlock.h"
4418 #include "sleeplock.h"
4419 #include "fs.h"
4420 #include "buf.h"
4421 #include "file.h"
4422 
4423 #define min(a, b) ((a) < (b) ? (a) : (b))
4424 static void itrunc(struct inode*);
4425 
4426 
4427 struct superblock sb;
4428 
4429 
4430 void
4431 readsb(int dev, struct superblock *sb)
4432 {
4433   struct buf *bp;
4434 
4435   bp = bread(dev, 1);
4436   memmove(sb, bp->data, sizeof(*sb));
4437   brelse(bp);
4438 }
4439 
4440 
4441 
4442 
4443 
4444 
4445 
4446 
4447 
4448 
4449 
4450 
4451 static void
4452 bzero(int dev, int bno)
4453 {
4454   struct buf *bp;
4455 
4456   bp = bread(dev, bno);
4457   memset(bp->data, 0, BSIZE);
4458   log_write(bp);
4459   brelse(bp);
4460 }
4461 
4462 
4463 
4464 
4465 static uint
4466 balloc(uint dev)
4467 {
4468   int b, bi, m;
4469   struct buf *bp;
4470 
4471   bp = 0;
4472   for(b = 0; b < sb.size; b += BPB){
4473     bp = bread(dev, BBLOCK(b, sb));
4474     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
4475       m = 1 << (bi % 8);
4476       if((bp->data[bi/8] & m) == 0){  
4477         bp->data[bi/8] |= m;  
4478         log_write(bp);
4479         brelse(bp);
4480         bzero(dev, b + bi);
4481         return b + bi;
4482       }
4483     }
4484     brelse(bp);
4485   }
4486   panic("balloc: out of blocks");
4487 }
4488 
4489 
4490 
4491 
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 
4501 static void
4502 bfree(int dev, uint b)
4503 {
4504   struct buf *bp;
4505   int bi, m;
4506 
4507   readsb(dev, &sb);
4508   bp = bread(dev, BBLOCK(b, sb));
4509   bi = b % BPB;
4510   m = 1 << (bi % 8);
4511   if((bp->data[bi/8] & m) == 0)
4512     panic("freeing free block");
4513   bp->data[bi/8] &= ~m;
4514   log_write(bp);
4515   brelse(bp);
4516 }
4517 
4518 
4519 
4520 
4521 
4522 
4523 
4524 
4525 
4526 
4527 
4528 
4529 
4530 
4531 
4532 
4533 
4534 
4535 
4536 
4537 
4538 
4539 
4540 
4541 
4542 
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550 
4551 
4552 
4553 
4554 
4555 
4556 
4557 
4558 
4559 
4560 
4561 
4562 
4563 
4564 
4565 
4566 
4567 
4568 
4569 
4570 
4571 
4572 
4573 
4574 
4575 
4576 
4577 
4578 struct {
4579   struct spinlock lock;
4580   struct inode inode[NINODE];
4581 } icache;
4582 
4583 void
4584 iinit(int dev)
4585 {
4586   int i = 0;
4587 
4588   initlock(&icache.lock, "icache");
4589   for(i = 0; i < NINODE; i++) {
4590     initsleeplock(&icache.inode[i].lock, "inode");
4591   }
4592 
4593   readsb(dev, &sb);
4594   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
4595  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
4596           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
4597           sb.bmapstart);
4598 }
4599 
4600 static struct inode* iget(uint dev, uint inum);
4601 
4602 
4603 
4604 struct inode*
4605 ialloc(uint dev, short type)
4606 {
4607   int inum;
4608   struct buf *bp;
4609   struct dinode *dip;
4610 
4611   for(inum = 1; inum < sb.ninodes; inum++){
4612     bp = bread(dev, IBLOCK(inum, sb));
4613     dip = (struct dinode*)bp->data + inum%IPB;
4614     if(dip->type == 0){  
4615       memset(dip, 0, sizeof(*dip));
4616       dip->type = type;
4617       log_write(bp);   
4618       brelse(bp);
4619       return iget(dev, inum);
4620     }
4621     brelse(bp);
4622   }
4623   panic("ialloc: no inodes");
4624 }
4625 
4626 
4627 void
4628 iupdate(struct inode *ip)
4629 {
4630   struct buf *bp;
4631   struct dinode *dip;
4632 
4633   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
4634   dip = (struct dinode*)bp->data + ip->inum%IPB;
4635   dip->type = ip->type;
4636   dip->major = ip->major;
4637   dip->minor = ip->minor;
4638   dip->nlink = ip->nlink;
4639   dip->size = ip->size;
4640   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
4641   log_write(bp);
4642   brelse(bp);
4643 }
4644 
4645 
4646 
4647 
4648 
4649 
4650 
4651 
4652 
4653 static struct inode*
4654 iget(uint dev, uint inum)
4655 {
4656   struct inode *ip, *empty;
4657 
4658   acquire(&icache.lock);
4659 
4660   
4661   empty = 0;
4662   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
4663     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
4664       ip->ref++;
4665       release(&icache.lock);
4666       return ip;
4667     }
4668     if(empty == 0 && ip->ref == 0)    
4669       empty = ip;
4670   }
4671 
4672   
4673   if(empty == 0)
4674     panic("iget: no inodes");
4675 
4676   ip = empty;
4677   ip->dev = dev;
4678   ip->inum = inum;
4679   ip->ref = 1;
4680   ip->flags = 0;
4681   release(&icache.lock);
4682 
4683   return ip;
4684 }
4685 
4686 
4687 
4688 struct inode*
4689 idup(struct inode *ip)
4690 {
4691   acquire(&icache.lock);
4692   ip->ref++;
4693   release(&icache.lock);
4694   return ip;
4695 }
4696 
4697 
4698 
4699 
4700 
4701 
4702 void
4703 ilock(struct inode *ip)
4704 {
4705   struct buf *bp;
4706   struct dinode *dip;
4707 
4708   if(ip == 0 || ip->ref < 1)
4709     panic("ilock");
4710 
4711   acquiresleep(&ip->lock);
4712 
4713   if(!(ip->flags & I_VALID)){
4714     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
4715     dip = (struct dinode*)bp->data + ip->inum%IPB;
4716     ip->type = dip->type;
4717     ip->major = dip->major;
4718     ip->minor = dip->minor;
4719     ip->nlink = dip->nlink;
4720     ip->size = dip->size;
4721     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
4722     brelse(bp);
4723     ip->flags |= I_VALID;
4724     if(ip->type == 0)
4725       panic("ilock: no type");
4726   }
4727 }
4728 
4729 
4730 void
4731 iunlock(struct inode *ip)
4732 {
4733   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
4734     panic("iunlock");
4735 
4736   releasesleep(&ip->lock);
4737 }
4738 
4739 
4740 
4741 
4742 
4743 
4744 
4745 
4746 
4747 
4748 
4749 
4750 
4751 
4752 
4753 
4754 
4755 
4756 
4757 void
4758 iput(struct inode *ip)
4759 {
4760   acquire(&icache.lock);
4761   if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
4762     
4763     release(&icache.lock);
4764     itrunc(ip);
4765     ip->type = 0;
4766     iupdate(ip);
4767     acquire(&icache.lock);
4768     ip->flags = 0;
4769   }
4770   ip->ref--;
4771   release(&icache.lock);
4772 }
4773 
4774 
4775 void
4776 iunlockput(struct inode *ip)
4777 {
4778   iunlock(ip);
4779   iput(ip);
4780 }
4781 
4782 
4783 
4784 
4785 
4786 
4787 
4788 
4789 
4790 
4791 static uint
4792 bmap(struct inode *ip, uint bn)
4793 {
4794   uint addr, *a;
4795   struct buf *bp;
4796 
4797   if(bn < NDIRECT){
4798     if((addr = ip->addrs[bn]) == 0)
4799       ip->addrs[bn] = addr = balloc(ip->dev);
4800     return addr;
4801   }
4802   bn -= NDIRECT;
4803 
4804   if(bn < NINDIRECT){
4805     
4806     if((addr = ip->addrs[NDIRECT]) == 0)
4807       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
4808     bp = bread(ip->dev, addr);
4809     a = (uint*)bp->data;
4810     if((addr = a[bn]) == 0){
4811       a[bn] = addr = balloc(ip->dev);
4812       log_write(bp);
4813     }
4814     brelse(bp);
4815     return addr;
4816   }
4817 
4818   panic("bmap: out of range");
4819 }
4820 
4821 
4822 
4823 
4824 
4825 
4826 static void
4827 itrunc(struct inode *ip)
4828 {
4829   int i, j;
4830   struct buf *bp;
4831   uint *a;
4832 
4833   for(i = 0; i < NDIRECT; i++){
4834     if(ip->addrs[i]){
4835       bfree(ip->dev, ip->addrs[i]);
4836       ip->addrs[i] = 0;
4837     }
4838   }
4839 
4840   if(ip->addrs[NDIRECT]){
4841     bp = bread(ip->dev, ip->addrs[NDIRECT]);
4842     a = (uint*)bp->data;
4843     for(j = 0; j < NINDIRECT; j++){
4844       if(a[j])
4845         bfree(ip->dev, a[j]);
4846     }
4847     brelse(bp);
4848     bfree(ip->dev, ip->addrs[NDIRECT]);
4849     ip->addrs[NDIRECT] = 0;
4850   }
4851 
4852   ip->size = 0;
4853   iupdate(ip);
4854 }
4855 
4856 
4857 void
4858 stati(struct inode *ip, struct stat *st)
4859 {
4860   st->dev = ip->dev;
4861   st->ino = ip->inum;
4862   st->type = ip->type;
4863   st->nlink = ip->nlink;
4864   st->size = ip->size;
4865 }
4866 
4867 
4868 int
4869 readi(struct inode *ip, char *dst, uint off, uint n)
4870 {
4871   uint tot, m;
4872   struct buf *bp;
4873 
4874   if(ip->type == T_DEV){
4875     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
4876       return -1;
4877     return devsw[ip->major].read(ip, dst, n);
4878   }
4879 
4880   if(off > ip->size || off + n < off)
4881     return -1;
4882   if(off + n > ip->size)
4883     n = ip->size - off;
4884 
4885   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
4886     bp = bread(ip->dev, bmap(ip, off/BSIZE));
4887     m = min(n - tot, BSIZE - off%BSIZE);
4888     /*
4889     cprintf("data off %d:\n", off);
4890     for (int j = 0; j < min(m, 10); j++) {
4891       cprintf("%x ", bp->data[off%BSIZE+j]);
4892     }
4893     cprintf("\n");
4894     */
4895     memmove(dst, bp->data + off%BSIZE, m);
4896     brelse(bp);
4897   }
4898   return n;
4899 }
4900 
4901 int
4902 writei(struct inode *ip, char *src, uint off, uint n)
4903 {
4904   uint tot, m;
4905   struct buf *bp;
4906 
4907   if(ip->type == T_DEV){
4908     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
4909       return -1;
4910     return devsw[ip->major].write(ip, src, n);
4911   }
4912 
4913   if(off > ip->size || off + n < off)
4914     return -1;
4915   if(off + n > MAXFILE*BSIZE)
4916     return -1;
4917 
4918   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
4919     bp = bread(ip->dev, bmap(ip, off/BSIZE));
4920     m = min(n - tot, BSIZE - off%BSIZE);
4921     memmove(bp->data + off%BSIZE, src, m);
4922     log_write(bp);
4923     brelse(bp);
4924   }
4925 
4926   if(n > 0 && off > ip->size){
4927     ip->size = off;
4928     iupdate(ip);
4929   }
4930   return n;
4931 }
4932 
4933 
4934 
4935 int
4936 namecmp(const char *s, const char *t)
4937 {
4938   return strncmp(s, t, DIRSIZ);
4939 }
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 
4951 
4952 struct inode*
4953 dirlookup(struct inode *dp, char *name, uint *poff)
4954 {
4955   uint off, inum;
4956   struct dirent de;
4957 
4958   if(dp->type != T_DIR)
4959     panic("dirlookup not DIR");
4960 
4961   for(off = 0; off < dp->size; off += sizeof(de)){
4962     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
4963       panic("dirlink read");
4964     if(de.inum == 0)
4965       continue;
4966     if(namecmp(name, de.name) == 0){
4967       
4968       if(poff)
4969         *poff = off;
4970       inum = de.inum;
4971       return iget(dp->dev, inum);
4972     }
4973   }
4974 
4975   return 0;
4976 }
4977 
4978 
4979 int
4980 dirlink(struct inode *dp, char *name, uint inum)
4981 {
4982   int off;
4983   struct dirent de;
4984   struct inode *ip;
4985 
4986   
4987   if((ip = dirlookup(dp, name, 0)) != 0){
4988     iput(ip);
4989     return -1;
4990   }
4991 
4992   
4993   for(off = 0; off < dp->size; off += sizeof(de)){
4994     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
4995       panic("dirlink read");
4996     if(de.inum == 0)
4997       break;
4998   }
4999 
5000   strncpy(de.name, name, DIRSIZ);
5001   de.inum = inum;
5002   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5003     panic("dirlink");
5004 
5005   return 0;
5006 }
5007 
5008 
5009 
5010 
5011 
5012 
5013 
5014 
5015 
5016 
5017 
5018 
5019 
5020 
5021 
5022 static char*
5023 skipelem(char *path, char *name)
5024 {
5025   char *s;
5026   int len;
5027 
5028   while(*path == '/')
5029     path++;
5030   if(*path == 0)
5031     return 0;
5032   s = path;
5033   while(*path != '/' && *path != 0)
5034     path++;
5035   len = path - s;
5036   if(len >= DIRSIZ)
5037     memmove(name, s, DIRSIZ);
5038   else {
5039     memmove(name, s, len);
5040     name[len] = 0;
5041   }
5042   while(*path == '/')
5043     path++;
5044   return path;
5045 }
5046 
5047 
5048 
5049 
5050 
5051 
5052 
5053 
5054 static struct inode*
5055 namex(char *path, int nameiparent, char *name)
5056 {
5057   struct inode *ip, *next;
5058 
5059   if(*path == '/')
5060     ip = iget(ROOTDEV, ROOTINO);
5061   else
5062     ip = idup(proc->cwd);
5063 
5064   while((path = skipelem(path, name)) != 0){
5065     ilock(ip);
5066     if(ip->type != T_DIR){
5067       iunlockput(ip);
5068       return 0;
5069     }
5070     if(nameiparent && *path == '\0'){
5071       
5072       iunlock(ip);
5073       return ip;
5074     }
5075     if((next = dirlookup(ip, name, 0)) == 0){
5076       iunlockput(ip);
5077       return 0;
5078     }
5079     iunlockput(ip);
5080     ip = next;
5081   }
5082   if(nameiparent){
5083     iput(ip);
5084     return 0;
5085   }
5086   return ip;
5087 }
5088 
5089 struct inode*
5090 namei(char *path)
5091 {
5092   char name[DIRSIZ];
5093   return namex(path, 0, name);
5094 }
5095 
5096 
5097 
5098 
5099 
5100 struct inode*
5101 nameiparent(char *path, char *name)
5102 {
5103   return namex(path, 1, name);
5104 }
5105 
5106 
5107 
5108 
5109 
5110 
5111 
5112 
5113 
5114 
5115 
5116 
5117 
5118 
5119 
5120 
5121 
5122 
5123 
5124 
5125 
5126 
5127 
5128 
5129 
5130 
5131 
5132 
5133 
5134 
5135 
5136 
5137 
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 
5152 
5153 
5154 #include "types.h"
5155 #include "defs.h"
5156 #include "param.h"
5157 #include "fs.h"
5158 #include "spinlock.h"
5159 #include "sleeplock.h"
5160 #include "file.h"
5161 
5162 struct devsw devsw[NDEV];
5163 struct {
5164   struct spinlock lock;
5165   struct file file[NFILE];
5166 } ftable;
5167 
5168 void
5169 fileinit(void)
5170 {
5171   initlock(&ftable.lock, "ftable");
5172 }
5173 
5174 
5175 struct file*
5176 filealloc(void)
5177 {
5178   struct file *f;
5179 
5180   acquire(&ftable.lock);
5181   for(f = ftable.file; f < ftable.file + NFILE; f++){
5182     if(f->ref == 0){
5183       f->ref = 1;
5184       release(&ftable.lock);
5185       return f;
5186     }
5187   }
5188   release(&ftable.lock);
5189   return 0;
5190 }
5191 
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 struct file*
5202 filedup(struct file *f)
5203 {
5204   acquire(&ftable.lock);
5205   if(f->ref < 1)
5206     panic("filedup");
5207   f->ref++;
5208   release(&ftable.lock);
5209   return f;
5210 }
5211 
5212 
5213 void
5214 fileclose(struct file *f)
5215 {
5216   struct file ff;
5217 
5218   acquire(&ftable.lock);
5219   if(f->ref < 1)
5220     panic("fileclose");
5221   if(--f->ref > 0){
5222     release(&ftable.lock);
5223     return;
5224   }
5225   ff = *f;
5226   f->ref = 0;
5227   f->type = FD_NONE;
5228   release(&ftable.lock);
5229 
5230   if(ff.type == FD_PIPE)
5231     pipeclose(ff.pipe, ff.writable);
5232   else if(ff.type == FD_INODE){
5233     begin_op();
5234     iput(ff.ip);
5235     end_op();
5236   }
5237 }
5238 
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 int
5252 filestat(struct file *f, struct stat *st)
5253 {
5254   if(f->type == FD_INODE){
5255     ilock(f->ip);
5256     stati(f->ip, st);
5257     iunlock(f->ip);
5258     return 0;
5259   }
5260   return -1;
5261 }
5262 
5263 
5264 int
5265 fileread(struct file *f, char *addr, int n)
5266 {
5267   int r;
5268 
5269   if(f->readable == 0)
5270     return -1;
5271   if(f->type == FD_PIPE)
5272     return piperead(f->pipe, addr, n);
5273   if(f->type == FD_INODE){
5274     ilock(f->ip);
5275     if((r = readi(f->ip, addr, f->off, n)) > 0)
5276       f->off += r;
5277     iunlock(f->ip);
5278     return r;
5279   }
5280   panic("fileread");
5281 }
5282 
5283 
5284 int
5285 filewrite(struct file *f, char *addr, int n)
5286 {
5287   int r;
5288 
5289   if(f->writable == 0)
5290     return -1;
5291   if(f->type == FD_PIPE)
5292     return pipewrite(f->pipe, addr, n);
5293   if(f->type == FD_INODE){
5294     
5295     
5296     
5297     
5298     
5299     
5300     int max = ((LOGSIZE-1-1-2) / 2) * 512;
5301     int i = 0;
5302     while(i < n){
5303       int n1 = n - i;
5304       if(n1 > max)
5305         n1 = max;
5306 
5307       begin_op();
5308       ilock(f->ip);
5309       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
5310         f->off += r;
5311       iunlock(f->ip);
5312       end_op();
5313 
5314       if(r < 0)
5315         break;
5316       if(r != n1)
5317         panic("short filewrite");
5318       i += r;
5319     }
5320     return i == n ? n : -1;
5321   }
5322   panic("filewrite");
5323 }
5324 
5325 
5326 
5327 
5328 
5329 
5330 
5331 
5332 
5333 
5334 
5335 
5336 
5337 
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 
5352 
5353 
5354 
5355 
5356 #include "types.h"
5357 #include "defs.h"
5358 #include "param.h"
5359 #include "stat.h"
5360 #include "mmu.h"
5361 #include "proc.h"
5362 #include "fs.h"
5363 #include "spinlock.h"
5364 #include "sleeplock.h"
5365 #include "file.h"
5366 #include "fcntl.h"
5367 
5368 
5369 
5370 static int
5371 argfd(int n, int *pfd, struct file **pf)
5372 {
5373   int fd;
5374   struct file *f;
5375 
5376   if(argint(n, &fd) < 0)
5377     return -1;
5378   if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
5379     return -1;
5380   if(pfd)
5381     *pfd = fd;
5382   if(pf)
5383     *pf = f;
5384   return 0;
5385 }
5386 
5387 
5388 
5389 
5390 
5391 
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 
5402 static int
5403 fdalloc(struct file *f)
5404 {
5405   int fd;
5406 
5407   for(fd = 0; fd < NOFILE; fd++){
5408     if(proc->ofile[fd] == 0){
5409       proc->ofile[fd] = f;
5410       return fd;
5411     }
5412   }
5413   return -1;
5414 }
5415 
5416 int
5417 sys_dup(void)
5418 {
5419   struct file *f;
5420   int fd;
5421 
5422   if(argfd(0, 0, &f) < 0)
5423     return -1;
5424   if((fd=fdalloc(f)) < 0)
5425     return -1;
5426   filedup(f);
5427   return fd;
5428 }
5429 
5430 int
5431 sys_read(void)
5432 {
5433   struct file *f;
5434   int n;
5435   char *p;
5436 
5437   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5438     return -1;
5439   return fileread(f, p, n);
5440 }
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 int
5451 sys_write(void)
5452 {
5453   struct file *f;
5454   int n;
5455   char *p;
5456 
5457   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5458     return -1;
5459   return filewrite(f, p, n);
5460 }
5461 
5462 int
5463 sys_close(void)
5464 {
5465   int fd;
5466   struct file *f;
5467 
5468   if(argfd(0, &fd, &f) < 0)
5469     return -1;
5470   proc->ofile[fd] = 0;
5471   fileclose(f);
5472   return 0;
5473 }
5474 
5475 int
5476 sys_fstat(void)
5477 {
5478   struct file *f;
5479   struct stat *st;
5480 
5481   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
5482     return -1;
5483   return filestat(f, st);
5484 }
5485 
5486 
5487 
5488 
5489 
5490 
5491 
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 int
5502 sys_link(void)
5503 {
5504   char name[DIRSIZ], *new, *old;
5505   struct inode *dp, *ip;
5506 
5507   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
5508     return -1;
5509 
5510   begin_op();
5511   if((ip = namei(old)) == 0){
5512     end_op();
5513     return -1;
5514   }
5515 
5516   ilock(ip);
5517   if(ip->type == T_DIR){
5518     iunlockput(ip);
5519     end_op();
5520     return -1;
5521   }
5522 
5523   ip->nlink++;
5524   iupdate(ip);
5525   iunlock(ip);
5526 
5527   if((dp = nameiparent(new, name)) == 0)
5528     goto bad;
5529   ilock(dp);
5530   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
5531     iunlockput(dp);
5532     goto bad;
5533   }
5534   iunlockput(dp);
5535   iput(ip);
5536 
5537   end_op();
5538 
5539   return 0;
5540 
5541 bad:
5542   ilock(ip);
5543   ip->nlink--;
5544   iupdate(ip);
5545   iunlockput(ip);
5546   end_op();
5547   return -1;
5548 }
5549 
5550 
5551 static int
5552 isdirempty(struct inode *dp)
5553 {
5554   int off;
5555   struct dirent de;
5556 
5557   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
5558     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5559       panic("isdirempty: readi");
5560     if(de.inum != 0)
5561       return 0;
5562   }
5563   return 1;
5564 }
5565 
5566 int
5567 sys_unlink(void)
5568 {
5569   struct inode *ip, *dp;
5570   struct dirent de;
5571   char name[DIRSIZ], *path;
5572   uint off;
5573 
5574   if(argstr(0, &path) < 0)
5575     return -1;
5576 
5577   begin_op();
5578   if((dp = nameiparent(path, name)) == 0){
5579     end_op();
5580     return -1;
5581   }
5582 
5583   ilock(dp);
5584 
5585   
5586   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
5587     goto bad;
5588 
5589   if((ip = dirlookup(dp, name, &off)) == 0)
5590     goto bad;
5591   ilock(ip);
5592 
5593   if(ip->nlink < 1)
5594     panic("unlink: nlink < 1");
5595   if(ip->type == T_DIR && !isdirempty(ip)){
5596     iunlockput(ip);
5597     goto bad;
5598   }
5599 
5600   memset(&de, 0, sizeof(de));
5601   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5602     panic("unlink: writei");
5603   if(ip->type == T_DIR){
5604     dp->nlink--;
5605     iupdate(dp);
5606   }
5607   iunlockput(dp);
5608 
5609   ip->nlink--;
5610   iupdate(ip);
5611   iunlockput(ip);
5612 
5613   end_op();
5614 
5615   return 0;
5616 
5617 bad:
5618   iunlockput(dp);
5619   end_op();
5620   return -1;
5621 }
5622 
5623 static struct inode*
5624 create(char *path, short type, short major, short minor)
5625 {
5626   uint off;
5627   struct inode *ip, *dp;
5628   char name[DIRSIZ];
5629 
5630   if((dp = nameiparent(path, name)) == 0)
5631     return 0;
5632   ilock(dp);
5633 
5634   if((ip = dirlookup(dp, name, &off)) != 0){
5635     iunlockput(dp);
5636     ilock(ip);
5637     if(type == T_FILE && ip->type == T_FILE)
5638       return ip;
5639     iunlockput(ip);
5640     return 0;
5641   }
5642 
5643   if((ip = ialloc(dp->dev, type)) == 0)
5644     panic("create: ialloc");
5645 
5646 
5647 
5648 
5649 
5650   ilock(ip);
5651   ip->major = major;
5652   ip->minor = minor;
5653   ip->nlink = 1;
5654   iupdate(ip);
5655 
5656   if(type == T_DIR){  
5657     dp->nlink++;  
5658     iupdate(dp);
5659     
5660     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
5661       panic("create dots");
5662   }
5663 
5664   if(dirlink(dp, name, ip->inum) < 0)
5665     panic("create: dirlink");
5666 
5667   iunlockput(dp);
5668 
5669   return ip;
5670 }
5671 
5672 int
5673 sys_open(void)
5674 {
5675   char *path;
5676   int fd, omode;
5677   struct file *f;
5678   struct inode *ip;
5679 
5680   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
5681     return -1;
5682 
5683   begin_op();
5684 
5685   if(omode & O_CREATE){
5686     ip = create(path, T_FILE, 0, 0);
5687     if(ip == 0){
5688       end_op();
5689       return -1;
5690     }
5691   } else {
5692     if((ip = namei(path)) == 0){
5693       end_op();
5694       return -1;
5695     }
5696     ilock(ip);
5697     if(ip->type == T_DIR && omode != O_RDONLY){
5698       iunlockput(ip);
5699       end_op();
5700       return -1;
5701     }
5702   }
5703 
5704   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
5705     if(f)
5706       fileclose(f);
5707     iunlockput(ip);
5708     end_op();
5709     return -1;
5710   }
5711   iunlock(ip);
5712   end_op();
5713 
5714   f->type = FD_INODE;
5715   f->ip = ip;
5716   f->off = 0;
5717   f->readable = !(omode & O_WRONLY);
5718   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
5719   return fd;
5720 }
5721 
5722 int
5723 sys_mkdir(void)
5724 {
5725   char *path;
5726   struct inode *ip;
5727 
5728   begin_op();
5729   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
5730     end_op();
5731     return -1;
5732   }
5733   iunlockput(ip);
5734   end_op();
5735   return 0;
5736 }
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 int
5751 sys_mknod(void)
5752 {
5753   struct inode *ip;
5754   char *path;
5755   int major, minor;
5756 
5757   begin_op();
5758   if((argstr(0, &path)) < 0 ||
5759      argint(1, &major) < 0 ||
5760      argint(2, &minor) < 0 ||
5761      (ip = create(path, T_DEV, major, minor)) == 0){
5762     end_op();
5763     return -1;
5764   }
5765   iunlockput(ip);
5766   end_op();
5767   return 0;
5768 }
5769 
5770 int
5771 sys_chdir(void)
5772 {
5773   char *path;
5774   struct inode *ip;
5775 
5776   begin_op();
5777   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
5778     end_op();
5779     return -1;
5780   }
5781   ilock(ip);
5782   if(ip->type != T_DIR){
5783     iunlockput(ip);
5784     end_op();
5785     return -1;
5786   }
5787   iunlock(ip);
5788   iput(proc->cwd);
5789   end_op();
5790   proc->cwd = ip;
5791   return 0;
5792 }
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 int
5801 sys_exec(void)
5802 {
5803   char *path, *argv[MAXARG];
5804   int i;
5805   uint uargv, uarg;
5806 
5807   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
5808     return -1;
5809   }
5810   memset(argv, 0, sizeof(argv));
5811   for(i=0;; i++){
5812     if(i >= NELEM(argv))
5813       return -1;
5814     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
5815       return -1;
5816     if(uarg == 0){
5817       argv[i] = 0;
5818       break;
5819     }
5820     if(fetchstr(uarg, &argv[i]) < 0)
5821       return -1;
5822   }
5823   return exec(path, argv);
5824 }
5825 
5826 int
5827 sys_pipe(void)
5828 {
5829   int *fd;
5830   struct file *rf, *wf;
5831   int fd0, fd1;
5832 
5833   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
5834     return -1;
5835   if(pipealloc(&rf, &wf) < 0)
5836     return -1;
5837   fd0 = -1;
5838   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
5839     if(fd0 >= 0)
5840       proc->ofile[fd0] = 0;
5841     fileclose(rf);
5842     fileclose(wf);
5843     return -1;
5844   }
5845   fd[0] = fd0;
5846   fd[1] = fd1;
5847   return 0;
5848 }
5849 
5850 #include "types.h"
5851 #include "param.h"
5852 #include "memlayout.h"
5853 #include "mmu.h"
5854 #include "proc.h"
5855 #include "defs.h"
5856 #include "x86.h"
5857 #include "elf.h"
5858 
5859 int
5860 exec(char *path, char **argv)
5861 {
5862   char *s, *last;
5863   int i, off;
5864   uint argc, sz, sp, ustack[3+MAXARG+1];
5865   struct elfhdr elf;
5866   struct inode *ip;
5867   struct proghdr ph;
5868   pde_t *pgdir, *oldpgdir;
5869 
5870   begin_op();
5871 
5872   if((ip = namei(path)) == 0){
5873     end_op();
5874     return -1;
5875   }
5876   ilock(ip);
5877   pgdir = 0;
5878 
5879   
5880   if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
5881     goto bad;
5882   if(elf.magic != ELF_MAGIC)
5883     goto bad;
5884 
5885   if((pgdir = setupkvm()) == 0)
5886     goto bad;
5887 
5888   
5889   sz = 0;
5890   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
5891     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
5892       goto bad;
5893     if(ph.type != ELF_PROG_LOAD)
5894       continue;
5895     if(ph.memsz < ph.filesz)
5896       goto bad;
5897     if(ph.vaddr + ph.memsz < ph.vaddr)
5898       goto bad;
5899     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
5900       goto bad;
5901     if(ph.vaddr % PGSIZE != 0)
5902       goto bad;
5903     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
5904       goto bad;
5905   }
5906   iunlockput(ip);
5907   end_op();
5908   ip = 0;
5909 
5910   
5911   
5912   sz = PGROUNDUP(sz);
5913   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
5914     goto bad;
5915   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
5916   sp = sz;
5917 
5918   
5919   for(argc = 0; argv[argc]; argc++) {
5920     if(argc >= MAXARG)
5921       goto bad;
5922     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
5923     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
5924       goto bad;
5925     ustack[3+argc] = sp;
5926   }
5927   ustack[3+argc] = 0;
5928 
5929   ustack[0] = 0xffffffff;  
5930   ustack[1] = argc;
5931   ustack[2] = sp - (argc+1)*4;  
5932 
5933   sp -= (3+argc+1) * 4;
5934   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
5935     goto bad;
5936 
5937   
5938   for(last=s=path; *s; s++)
5939     if(*s == '/')
5940       last = s+1;
5941   safestrcpy(proc->name, last, sizeof(proc->name));
5942 
5943   
5944   oldpgdir = proc->pgdir;
5945   proc->pgdir = pgdir;
5946   proc->sz = sz;
5947   proc->tf->eip = elf.entry;  
5948   proc->tf->esp = sp;
5949   switchuvm(proc);
5950   freevm(oldpgdir);
5951   return 0;
5952 
5953  bad:
5954   if(pgdir)
5955     freevm(pgdir);
5956   if(ip){
5957     iunlockput(ip);
5958     end_op();
5959   }
5960   return -1;
5961 }
5962 
5963 
5964 
5965 
5966 
5967 
5968 
5969 
5970 
5971 
5972 
5973 
5974 
5975 
5976 
5977 
5978 
5979 
5980 
5981 
5982 
5983 
5984 
5985 
5986 
5987 
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 #include "types.h"
6001 #include "defs.h"
6002 #include "param.h"
6003 #include "mmu.h"
6004 #include "proc.h"
6005 #include "fs.h"
6006 #include "spinlock.h"
6007 #include "sleeplock.h"
6008 #include "file.h"
6009 
6010 #define PIPESIZE 512
6011 
6012 struct pipe {
6013   struct spinlock lock;
6014   char data[PIPESIZE];
6015   uint nread;     
6016   uint nwrite;    
6017   int readopen;   
6018   int writeopen;  
6019 };
6020 
6021 int
6022 pipealloc(struct file **f0, struct file **f1)
6023 {
6024   struct pipe *p;
6025 
6026   p = 0;
6027   *f0 = *f1 = 0;
6028   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6029     goto bad;
6030   if((p = (struct pipe*)kalloc()) == 0)
6031     goto bad;
6032   p->readopen = 1;
6033   p->writeopen = 1;
6034   p->nwrite = 0;
6035   p->nread = 0;
6036   initlock(&p->lock, "pipe");
6037   (*f0)->type = FD_PIPE;
6038   (*f0)->readable = 1;
6039   (*f0)->writable = 0;
6040   (*f0)->pipe = p;
6041   (*f1)->type = FD_PIPE;
6042   (*f1)->readable = 0;
6043   (*f1)->writable = 1;
6044   (*f1)->pipe = p;
6045   return 0;
6046 
6047 
6048 
6049 
6050  bad:
6051   if(p)
6052     kfree((char*)p);
6053   if(*f0)
6054     fileclose(*f0);
6055   if(*f1)
6056     fileclose(*f1);
6057   return -1;
6058 }
6059 
6060 void
6061 pipeclose(struct pipe *p, int writable)
6062 {
6063   acquire(&p->lock);
6064   if(writable){
6065     p->writeopen = 0;
6066     wakeup(&p->nread);
6067   } else {
6068     p->readopen = 0;
6069     wakeup(&p->nwrite);
6070   }
6071   if(p->readopen == 0 && p->writeopen == 0){
6072     release(&p->lock);
6073     kfree((char*)p);
6074   } else
6075     release(&p->lock);
6076 }
6077 
6078 int
6079 pipewrite(struct pipe *p, char *addr, int n)
6080 {
6081   int i;
6082 
6083   acquire(&p->lock);
6084   for(i = 0; i < n; i++){
6085     while(p->nwrite == p->nread + PIPESIZE){  
6086       if(p->readopen == 0 || proc->killed){
6087         release(&p->lock);
6088         return -1;
6089       }
6090       wakeup(&p->nread);
6091       sleep(&p->nwrite, &p->lock);  
6092     }
6093     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6094   }
6095   wakeup(&p->nread);  
6096   release(&p->lock);
6097   return n;
6098 }
6099 
6100 int
6101 piperead(struct pipe *p, char *addr, int n)
6102 {
6103   int i;
6104 
6105   acquire(&p->lock);
6106   while(p->nread == p->nwrite && p->writeopen){  
6107     if(proc->killed){
6108       release(&p->lock);
6109       return -1;
6110     }
6111     sleep(&p->nread, &p->lock); 
6112   }
6113   for(i = 0; i < n; i++){  
6114     if(p->nread == p->nwrite)
6115       break;
6116     addr[i] = p->data[p->nread++ % PIPESIZE];
6117   }
6118   wakeup(&p->nwrite);  
6119   release(&p->lock);
6120   return i;
6121 }
6122 
6123 
6124 
6125 
6126 
6127 
6128 
6129 
6130 
6131 
6132 
6133 
6134 
6135 
6136 
6137 
6138 
6139 
6140 
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 #include "types.h"
6151 #include "x86.h"
6152 
6153 void*
6154 memset(void *dst, int c, uint n)
6155 {
6156   if ((int)dst%4 == 0 && n%4 == 0){
6157     c &= 0xFF;
6158     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
6159   } else
6160     stosb(dst, c, n);
6161   return dst;
6162 }
6163 
6164 int
6165 memcmp(const void *v1, const void *v2, uint n)
6166 {
6167   const uchar *s1, *s2;
6168 
6169   s1 = v1;
6170   s2 = v2;
6171   while(n-- > 0){
6172     if(*s1 != *s2)
6173       return *s1 - *s2;
6174     s1++, s2++;
6175   }
6176 
6177   return 0;
6178 }
6179 
6180 void*
6181 memmove(void *dst, const void *src, uint n)
6182 {
6183   const char *s;
6184   char *d;
6185 
6186   s = src;
6187   d = dst;
6188   if(s < d && s + n > d){
6189     s += n;
6190     d += n;
6191     while(n-- > 0)
6192       *--d = *--s;
6193   } else
6194     while(n-- > 0)
6195       *d++ = *s++;
6196 
6197   return dst;
6198 }
6199 
6200 
6201 void*
6202 memcpy(void *dst, const void *src, uint n)
6203 {
6204   return memmove(dst, src, n);
6205 }
6206 
6207 int
6208 strncmp(const char *p, const char *q, uint n)
6209 {
6210   while(n > 0 && *p && *p == *q)
6211     n--, p++, q++;
6212   if(n == 0)
6213     return 0;
6214   return (uchar)*p - (uchar)*q;
6215 }
6216 
6217 char*
6218 strncpy(char *s, const char *t, int n)
6219 {
6220   char *os;
6221 
6222   os = s;
6223   while(n-- > 0 && (*s++ = *t++) != 0)
6224     ;
6225   while(n-- > 0)
6226     *s++ = 0;
6227   return os;
6228 }
6229 
6230 
6231 char*
6232 safestrcpy(char *s, const char *t, int n)
6233 {
6234   char *os;
6235 
6236   os = s;
6237   if(n <= 0)
6238     return os;
6239   while(--n > 0 && (*s++ = *t++) != 0)
6240     ;
6241   *s = 0;
6242   return os;
6243 }
6244 
6245 
6246 
6247 
6248 
6249 
6250 int
6251 strlen(const char *s)
6252 {
6253   int n;
6254 
6255   for(n = 0; s[n]; n++)
6256     ;
6257   return n;
6258 }
6259 
6260 
6261 
6262 
6263 
6264 
6265 
6266 
6267 
6268 
6269 
6270 
6271 
6272 
6273 
6274 
6275 
6276 
6277 
6278 
6279 
6280 
6281 
6282 
6283 
6284 
6285 
6286 
6287 
6288 
6289 
6290 
6291 
6292 
6293 
6294 
6295 
6296 
6297 
6298 
6299 
6300 
6301 
6302 struct mp {             
6303   uchar signature[4];           
6304   void *physaddr;               
6305   uchar length;                 
6306   uchar specrev;                
6307   uchar checksum;               
6308   uchar type;                   
6309   uchar imcrp;
6310   uchar reserved[3];
6311 };
6312 
6313 struct mpconf {         
6314   uchar signature[4];           
6315   ushort length;                
6316   uchar version;                
6317   uchar checksum;               
6318   uchar product[20];            
6319   uint *oemtable;               
6320   ushort oemlength;             
6321   ushort entry;                 
6322   uint *lapicaddr;              
6323   ushort xlength;               
6324   uchar xchecksum;              
6325   uchar reserved;
6326 };
6327 
6328 struct mpproc {         
6329   uchar type;                   
6330   uchar apicid;                 
6331   uchar version;                
6332   uchar flags;                  
6333     #define MPBOOT 0x02           
6334   uchar signature[4];           
6335   uint feature;                 
6336   uchar reserved[8];
6337 };
6338 
6339 struct mpioapic {       
6340   uchar type;                   
6341   uchar apicno;                 
6342   uchar version;                
6343   uchar flags;                  
6344   uint *addr;                  
6345 };
6346 
6347 
6348 
6349 
6350 
6351 #define MPPROC    0x00  
6352 #define MPBUS     0x01  
6353 #define MPIOAPIC  0x02  
6354 #define MPIOINTR  0x03  
6355 #define MPLINTR   0x04  
6356 
6357 
6358 
6359 
6360 
6361 
6362 
6363 
6364 
6365 
6366 
6367 
6368 
6369 
6370 
6371 
6372 
6373 
6374 
6375 
6376 
6377 
6378 
6379 
6380 
6381 
6382 
6383 
6384 
6385 
6386 
6387 
6388 
6389 
6390 
6391 
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 
6401 
6402 
6403 
6404 #include "types.h"
6405 #include "defs.h"
6406 #include "param.h"
6407 #include "memlayout.h"
6408 #include "mp.h"
6409 #include "x86.h"
6410 #include "mmu.h"
6411 #include "proc.h"
6412 
6413 struct cpu cpus[NCPU];
6414 int ismp;
6415 int ncpu;
6416 uchar ioapicid;
6417 
6418 static uchar
6419 sum(uchar *addr, int len)
6420 {
6421   int i, sum;
6422 
6423   sum = 0;
6424   for(i=0; i<len; i++)
6425     sum += addr[i];
6426   return sum;
6427 }
6428 
6429 
6430 static struct mp*
6431 mpsearch1(uint a, int len)
6432 {
6433   uchar *e, *p, *addr;
6434 
6435   addr = P2V(a);
6436   e = addr+len;
6437   for(p = addr; p < e; p += sizeof(struct mp))
6438     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
6439       return (struct mp*)p;
6440   return 0;
6441 }
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 
6451 
6452 
6453 
6454 
6455 static struct mp*
6456 mpsearch(void)
6457 {
6458   uchar *bda;
6459   uint p;
6460   struct mp *mp;
6461 
6462   bda = (uchar *) P2V(0x400);
6463   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
6464     if((mp = mpsearch1(p, 1024)))
6465       return mp;
6466   } else {
6467     p = ((bda[0x14]<<8)|bda[0x13])*1024;
6468     if((mp = mpsearch1(p-1024, 1024)))
6469       return mp;
6470   }
6471   return mpsearch1(0xF0000, 0x10000);
6472 }
6473 
6474 
6475 
6476 
6477 
6478 
6479 static struct mpconf*
6480 mpconfig(struct mp **pmp)
6481 {
6482   struct mpconf *conf;
6483   struct mp *mp;
6484 
6485   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
6486     return 0;
6487   conf = (struct mpconf*) P2V((uint) mp->physaddr);
6488   if(memcmp(conf, "PCMP", 4) != 0)
6489     return 0;
6490   if(conf->version != 1 && conf->version != 4)
6491     return 0;
6492   if(sum((uchar*)conf, conf->length) != 0)
6493     return 0;
6494   *pmp = mp;
6495   return conf;
6496 }
6497 
6498 
6499 
6500 void
6501 mpinit(void)
6502 {
6503   uchar *p, *e;
6504   struct mp *mp;
6505   struct mpconf *conf;
6506   struct mpproc *proc;
6507   struct mpioapic *ioapic;
6508 
6509   if((conf = mpconfig(&mp)) == 0)
6510     return;
6511   ismp = 1;
6512   lapic = (uint*)conf->lapicaddr;
6513   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
6514     switch(*p){
6515     case MPPROC:
6516       proc = (struct mpproc*)p;
6517       if(ncpu < NCPU) {
6518         cpus[ncpu].apicid = proc->apicid;  
6519         ncpu++;
6520       }
6521       p += sizeof(struct mpproc);
6522       continue;
6523     case MPIOAPIC:
6524       ioapic = (struct mpioapic*)p;
6525       ioapicid = ioapic->apicno;
6526       p += sizeof(struct mpioapic);
6527       continue;
6528     case MPBUS:
6529     case MPIOINTR:
6530     case MPLINTR:
6531       p += 8;
6532       continue;
6533     default:
6534       ismp = 0;
6535       break;
6536     }
6537   }
6538   if(!ismp){
6539     
6540     ncpu = 1;
6541     lapic = 0;
6542     ioapicid = 0;
6543     return;
6544   }
6545 
6546 
6547 
6548 
6549 
6550   if(mp->imcrp){
6551     
6552     
6553     outb(0x22, 0x70);   
6554     outb(0x23, inb(0x23) | 1);  
6555   }
6556 }
6557 
6558 
6559 
6560 
6561 
6562 
6563 
6564 
6565 
6566 
6567 
6568 
6569 
6570 
6571 
6572 
6573 
6574 
6575 
6576 
6577 
6578 
6579 
6580 
6581 
6582 
6583 
6584 
6585 
6586 
6587 
6588 
6589 
6590 
6591 
6592 
6593 
6594 
6595 
6596 
6597 
6598 
6599 
6600 
6601 
6602 
6603 #include "param.h"
6604 #include "types.h"
6605 #include "defs.h"
6606 #include "date.h"
6607 #include "memlayout.h"
6608 #include "traps.h"
6609 #include "mmu.h"
6610 #include "x86.h"
6611 #include "proc.h"  
6612 
6613 
6614 #define ID      (0x0020/4)   
6615 #define VER     (0x0030/4)   
6616 #define TPR     (0x0080/4)   
6617 #define EOI     (0x00B0/4)   
6618 #define SVR     (0x00F0/4)   
6619   #define ENABLE     0x00000100   
6620 #define ESR     (0x0280/4)   
6621 #define ICRLO   (0x0300/4)   
6622   #define INIT       0x00000500   
6623   #define STARTUP    0x00000600   
6624   #define DELIVS     0x00001000   
6625   #define ASSERT     0x00004000   
6626   #define DEASSERT   0x00000000
6627   #define LEVEL      0x00008000   
6628   #define BCAST      0x00080000   
6629   #define BUSY       0x00001000
6630   #define FIXED      0x00000000
6631 #define ICRHI   (0x0310/4)   
6632 #define TIMER   (0x0320/4)   
6633   #define X1         0x0000000B   
6634   #define PERIODIC   0x00020000   
6635 #define PCINT   (0x0340/4)   
6636 #define LINT0   (0x0350/4)   
6637 #define LINT1   (0x0360/4)   
6638 #define ERROR   (0x0370/4)   
6639   #define MASKED     0x00010000   
6640 #define TICR    (0x0380/4)   
6641 #define TCCR    (0x0390/4)   
6642 #define TDCR    (0x03E0/4)   
6643 
6644 volatile uint *lapic;  
6645 
6646 
6647 
6648 
6649 
6650 static void
6651 lapicw(int index, int value)
6652 {
6653   lapic[index] = value;
6654   lapic[ID];  
6655 }
6656 
6657 void
6658 lapicinit(void)
6659 {
6660   if(!lapic)
6661     return;
6662 
6663   
6664   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
6665 
6666   
6667   
6668   
6669   
6670   lapicw(TDCR, X1);
6671   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
6672   lapicw(TICR, 10000000);
6673 
6674   
6675   lapicw(LINT0, MASKED);
6676   lapicw(LINT1, MASKED);
6677 
6678   
6679   
6680   if(((lapic[VER]>>16) & 0xFF) >= 4)
6681     lapicw(PCINT, MASKED);
6682 
6683   
6684   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
6685 
6686   
6687   lapicw(ESR, 0);
6688   lapicw(ESR, 0);
6689 
6690   
6691   lapicw(EOI, 0);
6692 
6693   
6694   lapicw(ICRHI, 0);
6695   lapicw(ICRLO, BCAST | INIT | LEVEL);
6696   while(lapic[ICRLO] & DELIVS)
6697     ;
6698 
6699 
6700   
6701   lapicw(TPR, 0);
6702 }
6703 
6704 int
6705 cpunum(void)
6706 {
6707   int apicid, i;
6708 
6709   
6710   
6711   
6712   
6713   
6714   if(readeflags()&FL_IF){
6715     static int n;
6716     if(n++ == 0)
6717       cprintf("cpu called from %x with interrupts enabled\n",
6718         __builtin_return_address(0));
6719   }
6720 
6721   if (!lapic)
6722     return 0;
6723 
6724   apicid = lapic[ID] >> 24;
6725   for (i = 0; i < ncpu; ++i) {
6726     if (cpus[i].apicid == apicid)
6727       return i;
6728   }
6729   panic("unknown apicid\n");
6730 }
6731 
6732 
6733 void
6734 lapiceoi(void)
6735 {
6736   if(lapic)
6737     lapicw(EOI, 0);
6738 }
6739 
6740 
6741 
6742 void
6743 microdelay(int us)
6744 {
6745 }
6746 
6747 
6748 
6749 
6750 #define CMOS_PORT    0x70
6751 #define CMOS_RETURN  0x71
6752 
6753 
6754 
6755 void
6756 lapicstartap(uchar apicid, uint addr)
6757 {
6758   int i;
6759   ushort *wrv;
6760 
6761   
6762   
6763   
6764   outb(CMOS_PORT, 0xF);  
6765   outb(CMOS_PORT+1, 0x0A);
6766   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
6767   wrv[0] = 0;
6768   wrv[1] = addr >> 4;
6769 
6770   
6771   
6772   lapicw(ICRHI, apicid<<24);
6773   lapicw(ICRLO, INIT | LEVEL | ASSERT);
6774   microdelay(200);
6775   lapicw(ICRLO, INIT | LEVEL);
6776   microdelay(100);    
6777 
6778   
6779   
6780   
6781   
6782   
6783   for(i = 0; i < 2; i++){
6784     lapicw(ICRHI, apicid<<24);
6785     lapicw(ICRLO, STARTUP | (addr>>12));
6786     microdelay(200);
6787   }
6788 }
6789 
6790 
6791 
6792 
6793 
6794 
6795 
6796 
6797 
6798 
6799 
6800 #define CMOS_STATA   0x0a
6801 #define CMOS_STATB   0x0b
6802 #define CMOS_UIP    (1 << 7)        
6803 
6804 #define SECS    0x00
6805 #define MINS    0x02
6806 #define HOURS   0x04
6807 #define DAY     0x07
6808 #define MONTH   0x08
6809 #define YEAR    0x09
6810 
6811 static uint cmos_read(uint reg)
6812 {
6813   outb(CMOS_PORT,  reg);
6814   microdelay(200);
6815 
6816   return inb(CMOS_RETURN);
6817 }
6818 
6819 static void fill_rtcdate(struct rtcdate *r)
6820 {
6821   r->second = cmos_read(SECS);
6822   r->minute = cmos_read(MINS);
6823   r->hour   = cmos_read(HOURS);
6824   r->day    = cmos_read(DAY);
6825   r->month  = cmos_read(MONTH);
6826   r->year   = cmos_read(YEAR);
6827 }
6828 
6829 
6830 void cmostime(struct rtcdate *r)
6831 {
6832   struct rtcdate t1, t2;
6833   int sb, bcd;
6834 
6835   sb = cmos_read(CMOS_STATB);
6836 
6837   bcd = (sb & (1 << 2)) == 0;
6838 
6839   
6840   for(;;) {
6841     fill_rtcdate(&t1);
6842     if(cmos_read(CMOS_STATA) & CMOS_UIP)
6843         continue;
6844     fill_rtcdate(&t2);
6845     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
6846       break;
6847   }
6848 
6849 
6850   
6851   if(bcd) {
6852 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
6853     CONV(second);
6854     CONV(minute);
6855     CONV(hour  );
6856     CONV(day   );
6857     CONV(month );
6858     CONV(year  );
6859 #undef     CONV
6860   }
6861 
6862   *r = t1;
6863   r->year += 2000;
6864 }
6865 
6866 
6867 
6868 
6869 
6870 
6871 
6872 
6873 
6874 
6875 
6876 
6877 
6878 
6879 
6880 
6881 
6882 
6883 
6884 
6885 
6886 
6887 
6888 
6889 
6890 
6891 
6892 
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 
6901 
6902 
6903 
6904 #include "types.h"
6905 #include "defs.h"
6906 #include "traps.h"
6907 
6908 #define IOAPIC  0xFEC00000   
6909 
6910 #define REG_ID     0x00  
6911 #define REG_VER    0x01  
6912 #define REG_TABLE  0x10  
6913 
6914 
6915 
6916 
6917 
6918 
6919 #define INT_DISABLED   0x00010000  
6920 #define INT_LEVEL      0x00008000  
6921 #define INT_ACTIVELOW  0x00002000  
6922 #define INT_LOGICAL    0x00000800  
6923 
6924 volatile struct ioapic *ioapic;
6925 
6926 
6927 struct ioapic {
6928   uint reg;
6929   uint pad[3];
6930   uint data;
6931 };
6932 
6933 static uint
6934 ioapicread(int reg)
6935 {
6936   ioapic->reg = reg;
6937   return ioapic->data;
6938 }
6939 
6940 static void
6941 ioapicwrite(int reg, uint data)
6942 {
6943   ioapic->reg = reg;
6944   ioapic->data = data;
6945 }
6946 
6947 
6948 
6949 
6950 void
6951 ioapicinit(void)
6952 {
6953   int i, id, maxintr;
6954 
6955   if(!ismp)
6956     return;
6957 
6958   ioapic = (volatile struct ioapic*)IOAPIC;
6959   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
6960   id = ioapicread(REG_ID) >> 24;
6961   if(id != ioapicid)
6962     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
6963 
6964   
6965   
6966   for(i = 0; i <= maxintr; i++){
6967     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
6968     ioapicwrite(REG_TABLE+2*i+1, 0);
6969   }
6970 }
6971 
6972 void
6973 ioapicenable(int irq, int cpunum)
6974 {
6975   if(!ismp)
6976     return;
6977 
6978   
6979   
6980   
6981   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
6982   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
6983 }
6984 
6985 
6986 
6987 
6988 
6989 
6990 
6991 
6992 
6993 
6994 
6995 
6996 
6997 
6998 
6999 
7000 
7001 
7002 #include "types.h"
7003 #include "x86.h"
7004 #include "traps.h"
7005 
7006 
7007 #define IO_PIC1         0x20    
7008 #define IO_PIC2         0xA0    
7009 
7010 #define IRQ_SLAVE       2       
7011 
7012 
7013 
7014 static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
7015 
7016 static void
7017 picsetmask(ushort mask)
7018 {
7019   irqmask = mask;
7020   outb(IO_PIC1+1, mask);
7021   outb(IO_PIC2+1, mask >> 8);
7022 }
7023 
7024 void
7025 picenable(int irq)
7026 {
7027   picsetmask(irqmask & ~(1<<irq));
7028 }
7029 
7030 
7031 void
7032 picinit(void)
7033 {
7034   
7035   outb(IO_PIC1+1, 0xFF);
7036   outb(IO_PIC2+1, 0xFF);
7037 
7038   
7039 
7040   
7041   
7042   
7043   
7044   outb(IO_PIC1, 0x11);
7045 
7046   
7047   outb(IO_PIC1+1, T_IRQ0);
7048 
7049 
7050   
7051   
7052   outb(IO_PIC1+1, 1<<IRQ_SLAVE);
7053 
7054   
7055   
7056   
7057   
7058   
7059   
7060   
7061   
7062   outb(IO_PIC1+1, 0x3);
7063 
7064   
7065   outb(IO_PIC2, 0x11);                  
7066   outb(IO_PIC2+1, T_IRQ0 + 8);      
7067   outb(IO_PIC2+1, IRQ_SLAVE);           
7068   
7069   
7070   outb(IO_PIC2+1, 0x3);                 
7071 
7072   
7073   
7074   
7075   
7076   outb(IO_PIC1, 0x68);             
7077   outb(IO_PIC1, 0x0a);             
7078 
7079   outb(IO_PIC2, 0x68);             
7080   outb(IO_PIC2, 0x0a);             
7081 
7082   if(irqmask != 0xFFFF)
7083     picsetmask(irqmask);
7084 }
7085 
7086 
7087 
7088 
7089 
7090 
7091 
7092 
7093 
7094 
7095 
7096 
7097 
7098 
7099 
7100 
7101 
7102 #define KBSTATP         0x64    
7103 #define KBS_DIB         0x01    
7104 #define KBDATAP         0x60    
7105 
7106 #define NO              0
7107 
7108 #define SHIFT           (1<<0)
7109 #define CTL             (1<<1)
7110 #define ALT             (1<<2)
7111 
7112 #define CAPSLOCK        (1<<3)
7113 #define NUMLOCK         (1<<4)
7114 #define SCROLLLOCK      (1<<5)
7115 
7116 #define E0ESC           (1<<6)
7117 
7118 
7119 #define KEY_HOME        0xE0
7120 #define KEY_END         0xE1
7121 #define KEY_UP          0xE2
7122 #define KEY_DN          0xE3
7123 #define KEY_LF          0xE4
7124 #define KEY_RT          0xE5
7125 #define KEY_PGUP        0xE6
7126 #define KEY_PGDN        0xE7
7127 #define KEY_INS         0xE8
7128 #define KEY_DEL         0xE9
7129 
7130 
7131 #define C(x) (x - '@')
7132 
7133 static uchar shiftcode[256] =
7134 {
7135   [0x1D] CTL,
7136   [0x2A] SHIFT,
7137   [0x36] SHIFT,
7138   [0x38] ALT,
7139   [0x9D] CTL,
7140   [0xB8] ALT
7141 };
7142 
7143 static uchar togglecode[256] =
7144 {
7145   [0x3A] CAPSLOCK,
7146   [0x45] NUMLOCK,
7147   [0x46] SCROLLLOCK
7148 };
7149 
7150 static uchar normalmap[256] =
7151 {
7152   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7153   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7154   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7155   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7156   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7157   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7158   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7159   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7160   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7161   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7162   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7163   [0x9C] '\n',      
7164   [0xB5] '/',       
7165   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7166   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7167   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7168   [0x97] KEY_HOME,  [0xCF] KEY_END,
7169   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7170 };
7171 
7172 static uchar shiftmap[256] =
7173 {
7174   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7175   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7176   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7177   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7178   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7179   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7180   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7181   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7182   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7183   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7184   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7185   [0x9C] '\n',      
7186   [0xB5] '/',       
7187   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7188   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7189   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7190   [0x97] KEY_HOME,  [0xCF] KEY_END,
7191   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7192 };
7193 
7194 
7195 
7196 
7197 
7198 
7199 
7200 static uchar ctlmap[256] =
7201 {
7202   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7203   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7204   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7205   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7206   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7207   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7208   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7209   [0x9C] '\r',      
7210   [0xB5] C('/'),    
7211   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7212   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7213   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7214   [0x97] KEY_HOME,  [0xCF] KEY_END,
7215   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7216 };
7217 
7218 
7219 
7220 
7221 
7222 
7223 
7224 
7225 
7226 
7227 
7228 
7229 
7230 
7231 
7232 
7233 
7234 
7235 
7236 
7237 
7238 
7239 
7240 
7241 
7242 
7243 
7244 
7245 
7246 
7247 
7248 
7249 
7250 #include "types.h"
7251 #include "x86.h"
7252 #include "defs.h"
7253 #include "kbd.h"
7254 
7255 int
7256 kbdgetc(void)
7257 {
7258   static uint shift;
7259   static uchar *charcode[4] = {
7260     normalmap, shiftmap, ctlmap, ctlmap
7261   };
7262   uint st, data, c;
7263 
7264   st = inb(KBSTATP);
7265   if((st & KBS_DIB) == 0)
7266     return -1;
7267   data = inb(KBDATAP);
7268 
7269   if(data == 0xE0){
7270     shift |= E0ESC;
7271     return 0;
7272   } else if(data & 0x80){
7273     
7274     data = (shift & E0ESC ? data : data & 0x7F);
7275     shift &= ~(shiftcode[data] | E0ESC);
7276     return 0;
7277   } else if(shift & E0ESC){
7278     
7279     data |= 0x80;
7280     shift &= ~E0ESC;
7281   }
7282 
7283   shift |= shiftcode[data];
7284   shift ^= togglecode[data];
7285   c = charcode[shift & (CTL | SHIFT)][data];
7286   if(shift & CAPSLOCK){
7287     if('a' <= c && c <= 'z')
7288       c += 'A' - 'a';
7289     else if('A' <= c && c <= 'Z')
7290       c += 'a' - 'A';
7291   }
7292   return c;
7293 }
7294 
7295 void
7296 kbdintr(void)
7297 {
7298   consoleintr(kbdgetc);
7299 }
7300 
7301 
7302 
7303 
7304 #include "types.h"
7305 #include "defs.h"
7306 #include "param.h"
7307 #include "traps.h"
7308 #include "spinlock.h"
7309 #include "sleeplock.h"
7310 #include "fs.h"
7311 #include "file.h"
7312 #include "memlayout.h"
7313 #include "mmu.h"
7314 #include "proc.h"
7315 #include "x86.h"
7316 
7317 static void consputc(int);
7318 
7319 static int panicked = 0;
7320 
7321 static struct {
7322   struct spinlock lock;
7323   int locking;
7324 } cons;
7325 
7326 static void
7327 printint(int xx, int base, int sign)
7328 {
7329   static char digits[] = "0123456789abcdef";
7330   char buf[16];
7331   int i;
7332   uint x;
7333 
7334   if(sign && (sign = xx < 0))
7335     x = -xx;
7336   else
7337     x = xx;
7338 
7339   i = 0;
7340   do{
7341     buf[i++] = digits[x % base];
7342   }while((x /= base) != 0);
7343 
7344   if(sign)
7345     buf[i++] = '-';
7346 
7347   while(--i >= 0)
7348     consputc(buf[i]);
7349 }
7350 
7351 void
7352 cprintf(char *fmt, ...)
7353 {
7354   int i, c, locking;
7355   uint *argp;
7356   char *s;
7357 
7358   locking = cons.locking;
7359   if(locking)
7360     acquire(&cons.lock);
7361 
7362   if (fmt == 0)
7363     panic("null fmt");
7364 
7365   argp = (uint*)(void*)(&fmt + 1);
7366   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
7367     if(c != '%'){
7368       consputc(c);
7369       continue;
7370     }
7371     c = fmt[++i] & 0xff;
7372     if(c == 0)
7373       break;
7374     switch(c){
7375     case 'd':
7376       printint(*argp++, 10, 1);
7377       break;
7378     case 'x':
7379     case 'p':
7380       printint(*argp++, 16, 0);
7381       break;
7382     case 's':
7383       if((s = (char*)*argp++) == 0)
7384         s = "(null)";
7385       for(; *s; s++)
7386         consputc(*s);
7387       break;
7388     case '%':
7389       consputc('%');
7390       break;
7391     default:
7392       
7393       consputc('%');
7394       consputc(c);
7395       break;
7396     }
7397   }
7398 
7399 
7400   if(locking)
7401     release(&cons.lock);
7402 }
7403 
7404 void
7405 panic(char *s)
7406 {
7407   int i;
7408   uint pcs[10];
7409 
7410   cli();
7411   cons.locking = 0;
7412   cprintf("cpu with apicid %d: panic: ", cpu->apicid);
7413   cprintf(s);
7414   cprintf("\n");
7415   getcallerpcs(&s, pcs);
7416   for(i=0; i<10; i++)
7417     cprintf(" %p", pcs[i]);
7418   panicked = 1; 
7419   for(;;)
7420     ;
7421 }
7422 
7423 #define BACKSPACE 0x100
7424 #define CRTPORT 0x3d4
7425 static ushort *crt = (ushort*)P2V(0xb8000);  
7426 
7427 static void
7428 cgaputc(int c)
7429 {
7430   int pos;
7431 
7432   
7433   outb(CRTPORT, 14);
7434   pos = inb(CRTPORT+1) << 8;
7435   outb(CRTPORT, 15);
7436   pos |= inb(CRTPORT+1);
7437 
7438   if(c == '\n')
7439     pos += 80 - pos%80;
7440   else if(c == BACKSPACE){
7441     if(pos > 0) --pos;
7442   } else
7443     crt[pos++] = (c&0xff) | 0x0700;  
7444 
7445   if(pos < 0 || pos > 25*80)
7446     panic("pos under/overflow");
7447 
7448 
7449 
7450   if((pos/80) >= 24){  
7451     memmove(crt, crt+80, sizeof(crt[0])*23*80);
7452     pos -= 80;
7453     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
7454   }
7455 
7456   outb(CRTPORT, 14);
7457   outb(CRTPORT+1, pos>>8);
7458   outb(CRTPORT, 15);
7459   outb(CRTPORT+1, pos);
7460   crt[pos] = ' ' | 0x0700;
7461 }
7462 
7463 void
7464 consputc(int c)
7465 {
7466   if(panicked){
7467     cli();
7468     for(;;)
7469       ;
7470   }
7471 
7472   if(c == BACKSPACE){
7473     uartputc('\b'); uartputc(' '); uartputc('\b');
7474   } else
7475     uartputc(c);
7476   cgaputc(c);
7477 }
7478 
7479 #define INPUT_BUF 128
7480 struct {
7481   char buf[INPUT_BUF];
7482   uint r;  
7483   uint w;  
7484   uint e;  
7485 } input;
7486 
7487 #define C(x)  ((x)-'@')  
7488 
7489 void
7490 consoleintr(int (*getc)(void))
7491 {
7492   int c, doprocdump = 0;
7493 
7494   acquire(&cons.lock);
7495   while((c = getc()) >= 0){
7496     switch(c){
7497     case C('P'):  
7498       
7499       doprocdump = 1;
7500       break;
7501     case C('U'):  
7502       while(input.e != input.w &&
7503             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
7504         input.e--;
7505         consputc(BACKSPACE);
7506       }
7507       break;
7508     case C('H'): case '\x7f':  
7509       if(input.e != input.w){
7510         input.e--;
7511         consputc(BACKSPACE);
7512       }
7513       break;
7514     default:
7515       if(c != 0 && input.e-input.r < INPUT_BUF){
7516         c = (c == '\r') ? '\n' : c;
7517         input.buf[input.e++ % INPUT_BUF] = c;
7518         consputc(c);
7519         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
7520           input.w = input.e;
7521           wakeup(&input.r);
7522         }
7523       }
7524       break;
7525     }
7526   }
7527   release(&cons.lock);
7528   if(doprocdump) {
7529     procdump();  
7530   }
7531 }
7532 
7533 int
7534 consoleread(struct inode *ip, char *dst, int n)
7535 {
7536   uint target;
7537   int c;
7538 
7539   iunlock(ip);
7540   target = n;
7541   acquire(&cons.lock);
7542   while(n > 0){
7543     while(input.r == input.w){
7544       if(proc->killed){
7545         release(&cons.lock);
7546         ilock(ip);
7547         return -1;
7548       }
7549       sleep(&input.r, &cons.lock);
7550     }
7551     c = input.buf[input.r++ % INPUT_BUF];
7552     if(c == C('D')){  
7553       if(n < target){
7554         
7555         
7556         input.r--;
7557       }
7558       break;
7559     }
7560     *dst++ = c;
7561     --n;
7562     if(c == '\n')
7563       break;
7564   }
7565   release(&cons.lock);
7566   ilock(ip);
7567 
7568   return target - n;
7569 }
7570 
7571 int
7572 consolewrite(struct inode *ip, char *buf, int n)
7573 {
7574   int i;
7575 
7576   iunlock(ip);
7577   acquire(&cons.lock);
7578   for(i = 0; i < n; i++)
7579     consputc(buf[i] & 0xff);
7580   release(&cons.lock);
7581   ilock(ip);
7582 
7583   return n;
7584 }
7585 
7586 void
7587 consoleinit(void)
7588 {
7589   initlock(&cons.lock, "console");
7590 
7591   devsw[CONSOLE].write = consolewrite;
7592   devsw[CONSOLE].read = consoleread;
7593   cons.locking = 1;
7594 
7595   picenable(IRQ_KBD);
7596   ioapicenable(IRQ_KBD, 0);
7597 }
7598 
7599 
7600 
7601 
7602 
7603 
7604 #include "types.h"
7605 #include "defs.h"
7606 #include "traps.h"
7607 #include "x86.h"
7608 
7609 #define IO_TIMER1       0x040           
7610 
7611 
7612 
7613 
7614 
7615 #define TIMER_FREQ      1193182
7616 #define TIMER_DIV(x)    ((TIMER_FREQ+(x)/2)/(x))
7617 
7618 #define TIMER_MODE      (IO_TIMER1 + 3) 
7619 #define TIMER_SEL0      0x00    
7620 #define TIMER_RATEGEN   0x04    
7621 #define TIMER_16BIT     0x30    
7622 
7623 void
7624 timerinit(void)
7625 {
7626   
7627   outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
7628   outb(IO_TIMER1, TIMER_DIV(100) % 256);
7629   outb(IO_TIMER1, TIMER_DIV(100) / 256);
7630   picenable(IRQ_TIMER);
7631 }
7632 
7633 
7634 
7635 
7636 
7637 
7638 
7639 
7640 
7641 
7642 
7643 
7644 
7645 
7646 
7647 
7648 
7649 
7650 
7651 
7652 #include "types.h"
7653 #include "defs.h"
7654 #include "param.h"
7655 #include "traps.h"
7656 #include "spinlock.h"
7657 #include "sleeplock.h"
7658 #include "fs.h"
7659 #include "file.h"
7660 #include "mmu.h"
7661 #include "proc.h"
7662 #include "x86.h"
7663 
7664 #define COM1    0x3f8
7665 
7666 static int uart;    
7667 
7668 void
7669 uartinit(void)
7670 {
7671   char *p;
7672 
7673   
7674   outb(COM1+2, 0);
7675 
7676   
7677   outb(COM1+3, 0x80);    
7678   outb(COM1+0, 115200/9600);
7679   outb(COM1+1, 0);
7680   outb(COM1+3, 0x03);    
7681   outb(COM1+4, 0);
7682   outb(COM1+1, 0x01);    
7683 
7684   
7685   if(inb(COM1+5) == 0xFF)
7686     return;
7687   uart = 1;
7688 
7689   
7690   
7691   inb(COM1+2);
7692   inb(COM1+0);
7693   picenable(IRQ_COM1);
7694   ioapicenable(IRQ_COM1, 0);
7695 
7696   
7697   for(p="xv6...\n"; *p; p++)
7698     uartputc(*p);
7699 }
7700 void
7701 uartputc(int c)
7702 {
7703   int i;
7704 
7705   if(!uart)
7706     return;
7707   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
7708     microdelay(10);
7709   outb(COM1+0, c);
7710 }
7711 
7712 static int
7713 uartgetc(void)
7714 {
7715   if(!uart)
7716     return -1;
7717   if(!(inb(COM1+5) & 0x01))
7718     return -1;
7719   return inb(COM1+0);
7720 }
7721 
7722 void
7723 uartintr(void)
7724 {
7725   consoleintr(uartgetc);
7726 }
7727 
7728 
7729 
7730 
7731 
7732 
7733 
7734 
7735 
7736 
7737 
7738 
7739 
7740 
7741 
7742 
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 
7751 
7752 
7753 
7754 
7755 
7756 
7757 
7758 .globl start
7759 start:
7760   pushl $argv
7761   pushl $init
7762   pushl $0  
7763   movl $SYS_exec, %eax
7764   int $T_SYSCALL
7765 
7766 
7767 exit:
7768   movl $SYS_exit, %eax
7769   int $T_SYSCALL
7770   jmp exit
7771 
7772 
7773 init:
7774   .string "/init\0"
7775 
7776 
7777 .p2align 2
7778 argv:
7779   .long init
7780   .long 0
7781 
7782 
7783 
7784 
7785 
7786 
7787 
7788 
7789 
7790 
7791 
7792 
7793 
7794 
7795 
7796 
7797 
7798 
7799 
7800 
7801 
7802 
7803 
7804   .globl name; \
7805   name: \
7806     movl $SYS_ 
7807     int $T_SYSCALL; \
7808     ret
7809 
7810 SYSCALL(fork)
7811 SYSCALL(exit)
7812 SYSCALL(wait)
7813 SYSCALL(pipe)
7814 SYSCALL(read)
7815 SYSCALL(write)
7816 SYSCALL(close)
7817 SYSCALL(kill)
7818 SYSCALL(exec)
7819 SYSCALL(open)
7820 SYSCALL(mknod)
7821 SYSCALL(unlink)
7822 SYSCALL(fstat)
7823 SYSCALL(link)
7824 SYSCALL(mkdir)
7825 SYSCALL(chdir)
7826 SYSCALL(dup)
7827 SYSCALL(getpid)
7828 SYSCALL(sbrk)
7829 SYSCALL(sleep)
7830 SYSCALL(uptime)
7831 
7832 
7833 
7834 
7835 
7836 
7837 
7838 
7839 
7840 
7841 
7842 
7843 
7844 
7845 
7846 
7847 
7848 
7849 
7850 
7851 
7852 #include "types.h"
7853 #include "stat.h"
7854 #include "user.h"
7855 #include "fcntl.h"
7856 
7857 char *argv[] = { "sh", 0 };
7858 
7859 int
7860 main(void)
7861 {
7862   int pid, wpid;
7863 
7864   if(open("console", O_RDWR) < 0){
7865     mknod("console", 1, 1);
7866     open("console", O_RDWR);
7867   }
7868   dup(0);  
7869   dup(0);  
7870 
7871   for(;;){
7872     printf(1, "init: starting sh\n");
7873     pid = fork();
7874     if(pid < 0){
7875       printf(1, "init: fork failed\n");
7876       exit();
7877     }
7878     if(pid == 0){
7879       exec("sh", argv);
7880       printf(1, "init: exec sh failed\n");
7881       exit();
7882     }
7883     while((wpid=wait()) >= 0 && wpid != pid)
7884       printf(1, "zombie!\n");
7885   }
7886 }
7887 
7888 
7889 
7890 
7891 
7892 
7893 
7894 
7895 
7896 
7897 
7898 
7899 
7900 
7901 
7902 #include "types.h"
7903 #include "user.h"
7904 #include "fcntl.h"
7905 
7906 
7907 #define EXEC  1
7908 #define REDIR 2
7909 #define PIPE  3
7910 #define LIST  4
7911 #define BACK  5
7912 
7913 #define MAXARGS 10
7914 
7915 struct cmd {
7916   int type;
7917 };
7918 
7919 struct execcmd {
7920   int type;
7921   char *argv[MAXARGS];
7922   char *eargv[MAXARGS];
7923 };
7924 
7925 struct redircmd {
7926   int type;
7927   struct cmd *cmd;
7928   char *file;
7929   char *efile;
7930   int mode;
7931   int fd;
7932 };
7933 
7934 struct pipecmd {
7935   int type;
7936   struct cmd *left;
7937   struct cmd *right;
7938 };
7939 
7940 struct listcmd {
7941   int type;
7942   struct cmd *left;
7943   struct cmd *right;
7944 };
7945 
7946 struct backcmd {
7947   int type;
7948   struct cmd *cmd;
7949 };
7950 int fork1(void);  
7951 void panic(char*);
7952 struct cmd *parsecmd(char*);
7953 
7954 
7955 void
7956 runcmd(struct cmd *cmd)
7957 {
7958   int p[2];
7959   struct backcmd *bcmd;
7960   struct execcmd *ecmd;
7961   struct listcmd *lcmd;
7962   struct pipecmd *pcmd;
7963   struct redircmd *rcmd;
7964 
7965   if(cmd == 0)
7966     exit();
7967 
7968   switch(cmd->type){
7969   default:
7970     panic("runcmd");
7971 
7972   case EXEC:
7973     ecmd = (struct execcmd*)cmd;
7974     if(ecmd->argv[0] == 0)
7975       exit();
7976     exec(ecmd->argv[0], ecmd->argv);
7977     printf(2, "exec %s failed\n", ecmd->argv[0]);
7978     break;
7979 
7980   case REDIR:
7981     rcmd = (struct redircmd*)cmd;
7982     close(rcmd->fd);
7983     if(open(rcmd->file, rcmd->mode) < 0){
7984       printf(2, "open %s failed\n", rcmd->file);
7985       exit();
7986     }
7987     runcmd(rcmd->cmd);
7988     break;
7989 
7990   case LIST:
7991     lcmd = (struct listcmd*)cmd;
7992     if(fork1() == 0)
7993       runcmd(lcmd->left);
7994     wait();
7995     runcmd(lcmd->right);
7996     break;
7997 
7998 
7999 
8000   case PIPE:
8001     pcmd = (struct pipecmd*)cmd;
8002     if(pipe(p) < 0)
8003       panic("pipe");
8004     if(fork1() == 0){
8005       close(1);
8006       dup(p[1]);
8007       close(p[0]);
8008       close(p[1]);
8009       runcmd(pcmd->left);
8010     }
8011     if(fork1() == 0){
8012       close(0);
8013       dup(p[0]);
8014       close(p[0]);
8015       close(p[1]);
8016       runcmd(pcmd->right);
8017     }
8018     close(p[0]);
8019     close(p[1]);
8020     wait();
8021     wait();
8022     break;
8023 
8024   case BACK:
8025     bcmd = (struct backcmd*)cmd;
8026     if(fork1() == 0)
8027       runcmd(bcmd->cmd);
8028     break;
8029   }
8030   exit();
8031 }
8032 
8033 int
8034 getcmd(char *buf, int nbuf)
8035 {
8036   printf(2, "$ ");
8037   memset(buf, 0, nbuf);
8038   gets(buf, nbuf);
8039   if(buf[0] == 0) 
8040     return -1;
8041   return 0;
8042 }
8043 
8044 
8045 
8046 
8047 
8048 
8049 
8050 int
8051 main(void)
8052 {
8053   static char buf[100];
8054   int fd;
8055 
8056   
8057   while((fd = open("console", O_RDWR)) >= 0){
8058     if(fd >= 3){
8059       close(fd);
8060       break;
8061     }
8062   }
8063 
8064   
8065   while(getcmd(buf, sizeof(buf)) >= 0){
8066     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8067       
8068       buf[strlen(buf)-1] = 0;  
8069       if(chdir(buf+3) < 0)
8070         printf(2, "cannot cd %s\n", buf+3);
8071       continue;
8072     }
8073     if(fork1() == 0)
8074       runcmd(parsecmd(buf));
8075     wait();
8076   }
8077   exit();
8078 }
8079 
8080 void
8081 panic(char *s)
8082 {
8083   printf(2, "%s\n", s);
8084   exit();
8085 }
8086 
8087 int
8088 fork1(void)
8089 {
8090   int pid;
8091 
8092   pid = fork();
8093   if(pid == -1)
8094     panic("fork");
8095   return pid;
8096 }
8097 
8098 
8099 
8100 
8101 
8102 struct cmd*
8103 execcmd(void)
8104 {
8105   struct execcmd *cmd;
8106 
8107   cmd = malloc(sizeof(*cmd));
8108   memset(cmd, 0, sizeof(*cmd));
8109   cmd->type = EXEC;
8110   return (struct cmd*)cmd;
8111 }
8112 
8113 struct cmd*
8114 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
8115 {
8116   struct redircmd *cmd;
8117 
8118   cmd = malloc(sizeof(*cmd));
8119   memset(cmd, 0, sizeof(*cmd));
8120   cmd->type = REDIR;
8121   cmd->cmd = subcmd;
8122   cmd->file = file;
8123   cmd->efile = efile;
8124   cmd->mode = mode;
8125   cmd->fd = fd;
8126   return (struct cmd*)cmd;
8127 }
8128 
8129 struct cmd*
8130 pipecmd(struct cmd *left, struct cmd *right)
8131 {
8132   struct pipecmd *cmd;
8133 
8134   cmd = malloc(sizeof(*cmd));
8135   memset(cmd, 0, sizeof(*cmd));
8136   cmd->type = PIPE;
8137   cmd->left = left;
8138   cmd->right = right;
8139   return (struct cmd*)cmd;
8140 }
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 struct cmd*
8151 listcmd(struct cmd *left, struct cmd *right)
8152 {
8153   struct listcmd *cmd;
8154 
8155   cmd = malloc(sizeof(*cmd));
8156   memset(cmd, 0, sizeof(*cmd));
8157   cmd->type = LIST;
8158   cmd->left = left;
8159   cmd->right = right;
8160   return (struct cmd*)cmd;
8161 }
8162 
8163 struct cmd*
8164 backcmd(struct cmd *subcmd)
8165 {
8166   struct backcmd *cmd;
8167 
8168   cmd = malloc(sizeof(*cmd));
8169   memset(cmd, 0, sizeof(*cmd));
8170   cmd->type = BACK;
8171   cmd->cmd = subcmd;
8172   return (struct cmd*)cmd;
8173 }
8174 
8175 
8176 char whitespace[] = " \t\r\n\v";
8177 char symbols[] = "<|>&;()";
8178 
8179 int
8180 gettoken(char **ps, char *es, char **q, char **eq)
8181 {
8182   char *s;
8183   int ret;
8184 
8185   s = *ps;
8186   while(s < es && strchr(whitespace, *s))
8187     s++;
8188   if(q)
8189     *q = s;
8190   ret = *s;
8191   switch(*s){
8192   case 0:
8193     break;
8194   case '|':
8195   case '(':
8196   case ')':
8197   case ';':
8198   case '&':
8199   case '<':
8200     s++;
8201     break;
8202   case '>':
8203     s++;
8204     if(*s == '>'){
8205       ret = '+';
8206       s++;
8207     }
8208     break;
8209   default:
8210     ret = 'a';
8211     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
8212       s++;
8213     break;
8214   }
8215   if(eq)
8216     *eq = s;
8217 
8218   while(s < es && strchr(whitespace, *s))
8219     s++;
8220   *ps = s;
8221   return ret;
8222 }
8223 
8224 int
8225 peek(char **ps, char *es, char *toks)
8226 {
8227   char *s;
8228 
8229   s = *ps;
8230   while(s < es && strchr(whitespace, *s))
8231     s++;
8232   *ps = s;
8233   return *s && strchr(toks, *s);
8234 }
8235 
8236 
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 struct cmd *parseline(char**, char*);
8251 struct cmd *parsepipe(char**, char*);
8252 struct cmd *parseexec(char**, char*);
8253 struct cmd *nulterminate(struct cmd*);
8254 
8255 struct cmd*
8256 parsecmd(char *s)
8257 {
8258   char *es;
8259   struct cmd *cmd;
8260 
8261   es = s + strlen(s);
8262   cmd = parseline(&s, es);
8263   peek(&s, es, "");
8264   if(s != es){
8265     printf(2, "leftovers: %s\n", s);
8266     panic("syntax");
8267   }
8268   nulterminate(cmd);
8269   return cmd;
8270 }
8271 
8272 struct cmd*
8273 parseline(char **ps, char *es)
8274 {
8275   struct cmd *cmd;
8276 
8277   cmd = parsepipe(ps, es);
8278   while(peek(ps, es, "&")){
8279     gettoken(ps, es, 0, 0);
8280     cmd = backcmd(cmd);
8281   }
8282   if(peek(ps, es, ";")){
8283     gettoken(ps, es, 0, 0);
8284     cmd = listcmd(cmd, parseline(ps, es));
8285   }
8286   return cmd;
8287 }
8288 
8289 
8290 
8291 
8292 
8293 
8294 
8295 
8296 
8297 
8298 
8299 
8300 struct cmd*
8301 parsepipe(char **ps, char *es)
8302 {
8303   struct cmd *cmd;
8304 
8305   cmd = parseexec(ps, es);
8306   if(peek(ps, es, "|")){
8307     gettoken(ps, es, 0, 0);
8308     cmd = pipecmd(cmd, parsepipe(ps, es));
8309   }
8310   return cmd;
8311 }
8312 
8313 struct cmd*
8314 parseredirs(struct cmd *cmd, char **ps, char *es)
8315 {
8316   int tok;
8317   char *q, *eq;
8318 
8319   while(peek(ps, es, "<>")){
8320     tok = gettoken(ps, es, 0, 0);
8321     if(gettoken(ps, es, &q, &eq) != 'a')
8322       panic("missing file for redirection");
8323     switch(tok){
8324     case '<':
8325       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
8326       break;
8327     case '>':
8328       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8329       break;
8330     case '+':  
8331       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8332       break;
8333     }
8334   }
8335   return cmd;
8336 }
8337 
8338 
8339 
8340 
8341 
8342 
8343 
8344 
8345 
8346 
8347 
8348 
8349 
8350 struct cmd*
8351 parseblock(char **ps, char *es)
8352 {
8353   struct cmd *cmd;
8354 
8355   if(!peek(ps, es, "("))
8356     panic("parseblock");
8357   gettoken(ps, es, 0, 0);
8358   cmd = parseline(ps, es);
8359   if(!peek(ps, es, ")"))
8360     panic("syntax - missing )");
8361   gettoken(ps, es, 0, 0);
8362   cmd = parseredirs(cmd, ps, es);
8363   return cmd;
8364 }
8365 
8366 struct cmd*
8367 parseexec(char **ps, char *es)
8368 {
8369   char *q, *eq;
8370   int tok, argc;
8371   struct execcmd *cmd;
8372   struct cmd *ret;
8373 
8374   if(peek(ps, es, "("))
8375     return parseblock(ps, es);
8376 
8377   ret = execcmd();
8378   cmd = (struct execcmd*)ret;
8379 
8380   argc = 0;
8381   ret = parseredirs(ret, ps, es);
8382   while(!peek(ps, es, "|)&;")){
8383     if((tok=gettoken(ps, es, &q, &eq)) == 0)
8384       break;
8385     if(tok != 'a')
8386       panic("syntax");
8387     cmd->argv[argc] = q;
8388     cmd->eargv[argc] = eq;
8389     argc++;
8390     if(argc >= MAXARGS)
8391       panic("too many args");
8392     ret = parseredirs(ret, ps, es);
8393   }
8394   cmd->argv[argc] = 0;
8395   cmd->eargv[argc] = 0;
8396   return ret;
8397 }
8398 
8399 
8400 
8401 struct cmd*
8402 nulterminate(struct cmd *cmd)
8403 {
8404   int i;
8405   struct backcmd *bcmd;
8406   struct execcmd *ecmd;
8407   struct listcmd *lcmd;
8408   struct pipecmd *pcmd;
8409   struct redircmd *rcmd;
8410 
8411   if(cmd == 0)
8412     return 0;
8413 
8414   switch(cmd->type){
8415   case EXEC:
8416     ecmd = (struct execcmd*)cmd;
8417     for(i=0; ecmd->argv[i]; i++)
8418       *ecmd->eargv[i] = 0;
8419     break;
8420 
8421   case REDIR:
8422     rcmd = (struct redircmd*)cmd;
8423     nulterminate(rcmd->cmd);
8424     *rcmd->efile = 0;
8425     break;
8426 
8427   case PIPE:
8428     pcmd = (struct pipecmd*)cmd;
8429     nulterminate(pcmd->left);
8430     nulterminate(pcmd->right);
8431     break;
8432 
8433   case LIST:
8434     lcmd = (struct listcmd*)cmd;
8435     nulterminate(lcmd->left);
8436     nulterminate(lcmd->right);
8437     break;
8438 
8439   case BACK:
8440     bcmd = (struct backcmd*)cmd;
8441     nulterminate(bcmd->cmd);
8442     break;
8443   }
8444   return cmd;
8445 }
8446 
8447 
8448 
8449 
8450 
8451 
8452 
8453 
8454 
8455 
8456 
8457 
8458 
8459 .code16                       
8460 .globl start
8461 start:
8462   cli                         
8463 
8464   
8465   xorw    %ax,%ax             
8466   movw    %ax,%ds             
8467   movw    %ax,%es             
8468   movw    %ax,%ss             
8469 
8470   
8471   
8472 seta20.1:
8473   inb     $0x64,%al               
8474   testb   $0x2,%al
8475   jnz     seta20.1
8476 
8477   movb    $0xd1,%al               
8478   outb    %al,$0x64
8479 
8480 seta20.2:
8481   inb     $0x64,%al               
8482   testb   $0x2,%al
8483   jnz     seta20.2
8484 
8485   movb    $0xdf,%al               
8486   outb    %al,$0x60
8487 
8488   
8489   
8490   
8491   lgdt    gdtdesc
8492   movl    %cr0, %eax
8493   orl     $CR0_PE, %eax
8494   movl    %eax, %cr0
8495 
8496   
8497   
8498   
8499   ljmp    $(SEG_KCODE<<3), $start32
8500 .code32  
8501 start32:
8502   
8503   movw    $(SEG_KDATA<<3), %ax    
8504   movw    %ax, %ds                
8505   movw    %ax, %es                
8506   movw    %ax, %ss                
8507   movw    $0, %ax                 
8508   movw    %ax, %fs                
8509   movw    %ax, %gs                
8510 
8511   
8512   movl    $start, %esp
8513   call    bootmain
8514 
8515   
8516   
8517   movw    $0x8a00, %ax            
8518   movw    %ax, %dx
8519   outw    %ax, %dx
8520   movw    $0x8ae0, %ax            
8521   outw    %ax, %dx
8522 spin:
8523   jmp     spin
8524 
8525 
8526 .p2align 2                                
8527 gdt:
8528   SEG_NULLASM                             
8529   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
8530   SEG_ASM(STA_W, 0x0, 0xffffffff)         
8531 
8532 gdtdesc:
8533   .word   (gdtdesc - gdt - 1)             
8534   .long   gdt                             
8535 
8536 
8537 
8538 
8539 
8540 
8541 
8542 
8543 
8544 
8545 
8546 
8547 
8548 
8549 
8550 
8551 
8552 
8553 
8554 
8555 
8556 
8557 #include "types.h"
8558 #include "elf.h"
8559 #include "x86.h"
8560 #include "memlayout.h"
8561 
8562 #define SECTSIZE  512
8563 
8564 void readseg(uchar*, uint, uint);
8565 
8566 void
8567 bootmain(void)
8568 {
8569   struct elfhdr *elf;
8570   struct proghdr *ph, *eph;
8571   void (*entry)(void);
8572   uchar* pa;
8573 
8574   elf = (struct elfhdr*)0x10000;  
8575 
8576   
8577   readseg((uchar*)elf, 4096, 0);
8578 
8579   
8580   if(elf->magic != ELF_MAGIC)
8581     return;  
8582 
8583   
8584   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
8585   eph = ph + elf->phnum;
8586   for(; ph < eph; ph++){
8587     pa = (uchar*)ph->paddr;
8588     readseg(pa, ph->filesz, ph->off);
8589     if(ph->memsz > ph->filesz)
8590       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
8591   }
8592 
8593   
8594   
8595   entry = (void(*)(void))(elf->entry);
8596   entry();
8597 }
8598 
8599 
8600 void
8601 waitdisk(void)
8602 {
8603   
8604   while((inb(0x1F7) & 0xC0) != 0x40)
8605     ;
8606 }
8607 
8608 
8609 void
8610 readsect(void *dst, uint offset)
8611 {
8612   
8613   waitdisk();
8614   outb(0x1F2, 1);   
8615   outb(0x1F3, offset);
8616   outb(0x1F4, offset >> 8);
8617   outb(0x1F5, offset >> 16);
8618   outb(0x1F6, (offset >> 24) | 0xE0);
8619   outb(0x1F7, 0x20);  
8620 
8621   
8622   waitdisk();
8623   insl(0x1F0, dst, SECTSIZE/4);
8624 }
8625 
8626 
8627 
8628 void
8629 readseg(uchar* pa, uint count, uint offset)
8630 {
8631   uchar* epa;
8632 
8633   epa = pa + count;
8634 
8635   
8636   pa -= offset % SECTSIZE;
8637 
8638   
8639   offset = (offset / SECTSIZE) + 1;
8640 
8641   
8642   
8643   
8644   for(; pa < epa; pa += SECTSIZE, offset++)
8645     readsect(pa, offset);
8646 }
8647 
8648 
8649 
